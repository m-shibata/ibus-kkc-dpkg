/* setup.c generated by valac 0.20.1, the Vala compiler
 * generated from setup.vala, do not modify */

/* 
 * Copyright (C) 2011-2013 Daiki Ueno <ueno@gnu.org>
 * Copyright (C) 2011-2013 Red Hat, Inc.
 * 
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

#include <glib.h>
#include <glib-object.h>
#include <gtk/gtk.h>
#include <libutil.h>
#include <libkkc/libkkc.h>
#include <stdlib.h>
#include <string.h>
#include <gdk/gdk.h>
#include <glib/gi18n-lib.h>
#include <gee.h>
#include <float.h>
#include <math.h>
#include <ibus.h>
#include <config.h>
#include <stdio.h>


#define TYPE_SETUP (setup_get_type ())
#define SETUP(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_SETUP, Setup))
#define SETUP_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_SETUP, SetupClass))
#define IS_SETUP(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_SETUP))
#define IS_SETUP_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_SETUP))
#define SETUP_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_SETUP, SetupClass))

typedef struct _Setup Setup;
typedef struct _SetupClass SetupClass;
typedef struct _SetupPrivate SetupPrivate;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
typedef struct _Block1Data Block1Data;
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))

#define SETUP_TYPE_DICT_CELL_RENDERER (setup_dict_cell_renderer_get_type ())
#define SETUP_DICT_CELL_RENDERER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), SETUP_TYPE_DICT_CELL_RENDERER, SetupDictCellRenderer))
#define SETUP_DICT_CELL_RENDERER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), SETUP_TYPE_DICT_CELL_RENDERER, SetupDictCellRendererClass))
#define SETUP_IS_DICT_CELL_RENDERER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), SETUP_TYPE_DICT_CELL_RENDERER))
#define SETUP_IS_DICT_CELL_RENDERER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), SETUP_TYPE_DICT_CELL_RENDERER))
#define SETUP_DICT_CELL_RENDERER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), SETUP_TYPE_DICT_CELL_RENDERER, SetupDictCellRendererClass))

typedef struct _SetupDictCellRenderer SetupDictCellRenderer;
typedef struct _SetupDictCellRendererClass SetupDictCellRendererClass;

#define SETUP_TYPE_KEY_EVENT_CELL_RENDERER (setup_key_event_cell_renderer_get_type ())
#define SETUP_KEY_EVENT_CELL_RENDERER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), SETUP_TYPE_KEY_EVENT_CELL_RENDERER, SetupKeyEventCellRenderer))
#define SETUP_KEY_EVENT_CELL_RENDERER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), SETUP_TYPE_KEY_EVENT_CELL_RENDERER, SetupKeyEventCellRendererClass))
#define SETUP_IS_KEY_EVENT_CELL_RENDERER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), SETUP_TYPE_KEY_EVENT_CELL_RENDERER))
#define SETUP_IS_KEY_EVENT_CELL_RENDERER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), SETUP_TYPE_KEY_EVENT_CELL_RENDERER))
#define SETUP_KEY_EVENT_CELL_RENDERER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), SETUP_TYPE_KEY_EVENT_CELL_RENDERER, SetupKeyEventCellRendererClass))

typedef struct _SetupKeyEventCellRenderer SetupKeyEventCellRenderer;
typedef struct _SetupKeyEventCellRendererClass SetupKeyEventCellRendererClass;
#define _g_free0(var) (var = (g_free (var), NULL))
#define _gtk_tree_path_free0(var) ((var == NULL) ? NULL : (var = (gtk_tree_path_free (var), NULL)))
#define __g_list_free__gtk_tree_path_free0_0(var) ((var == NULL) ? NULL : (var = (_g_list_free__gtk_tree_path_free0_ (var), NULL)))
#define _g_variant_unref0(var) ((var == NULL) ? NULL : (var = (g_variant_unref (var), NULL)))
typedef struct _Block2Data Block2Data;
typedef struct _Block3Data Block3Data;
typedef struct _Block4Data Block4Data;
typedef struct _Block5Data Block5Data;
typedef struct _SetupDictCellRendererPrivate SetupDictCellRendererPrivate;
typedef struct _SetupKeyEventCellRendererPrivate SetupKeyEventCellRendererPrivate;
#define _vala_assert(expr, msg) if G_LIKELY (expr) ; else g_assertion_message_expr (G_LOG_DOMAIN, __FILE__, __LINE__, G_STRFUNC, msg);

struct _Setup {
	GObject parent_instance;
	SetupPrivate * priv;
};

struct _SetupClass {
	GObjectClass parent_class;
};

struct _SetupPrivate {
	GtkDialog* dialog;
	GtkTreeView* dictionaries_treeview;
	GtkTreeView* available_dictionaries_treeview;
	GtkComboBox* punctuation_style_combobox;
	GtkCheckButton* auto_correct_checkbutton;
	GtkCheckButton* use_custom_keymap_checkbutton;
	GtkComboBox* keymap_combobox;
	GtkSpinButton* page_size_spinbutton;
	GtkSpinButton* pagination_start_spinbutton;
	GtkCheckButton* show_annotation_checkbutton;
	GtkComboBox* initial_input_mode_combobox;
	GtkComboBox* typing_rule_combobox;
	GtkTreeView* input_mode_treeview;
	GtkTreeView* shortcut_treeview;
	GtkToolButton* add_shortcut_toolbutton;
	GtkToolButton* remove_shortcut_toolbutton;
	GtkDialog* dict_dialog;
	GtkDialog* shortcut_dialog;
	GtkComboBox* shortcut_command_combobox;
	Preferences* preferences;
	KkcUserRule* shortcut_rule;
	KkcInputMode shortcut_input_mode;
};

struct _Block1Data {
	int _ref_count_;
	Setup * self;
	GtkToolButton* remove_dict_toolbutton;
	GtkToolButton* up_dict_toolbutton;
	GtkToolButton* down_dict_toolbutton;
	GtkTreeSelection* input_mode_selection;
	GtkTreeSelection* shortcut_selection;
	GtkTreeSelection* dictionaries_selection;
};

struct _Block2Data {
	int _ref_count_;
	Setup * self;
	gchar* name;
	GtkSpinButton* spin;
};

struct _Block3Data {
	int _ref_count_;
	Setup * self;
	gchar* name;
	GtkToggleButton* toggle;
};

struct _Block4Data {
	int _ref_count_;
	Setup * self;
	gchar* name;
	GtkComboBox* combo;
	gint column;
};

struct _Block5Data {
	int _ref_count_;
	Setup * self;
	gchar* name;
	GtkComboBox* combo;
	gint column;
};

struct _SetupDictCellRenderer {
	GtkCellRendererText parent_instance;
	SetupDictCellRendererPrivate * priv;
};

struct _SetupDictCellRendererClass {
	GtkCellRendererTextClass parent_class;
};

struct _SetupDictCellRendererPrivate {
	DictionaryMetadata* _metadata;
};

struct _SetupKeyEventCellRenderer {
	GtkCellRendererAccel parent_instance;
	SetupKeyEventCellRendererPrivate * priv;
};

struct _SetupKeyEventCellRendererClass {
	GtkCellRendererAccelClass parent_class;
};

struct _SetupKeyEventCellRendererPrivate {
	KkcKeyEvent* _event;
};


static gpointer setup_parent_class = NULL;
static gpointer setup_dict_cell_renderer_parent_class = NULL;
static gpointer setup_key_event_cell_renderer_parent_class = NULL;

GType setup_get_type (void) G_GNUC_CONST;
#define SETUP_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), TYPE_SETUP, SetupPrivate))
enum  {
	SETUP_DUMMY_PROPERTY
};
Setup* setup_new (Preferences* preferences);
Setup* setup_construct (GType object_type, Preferences* preferences);
static Block1Data* block1_data_ref (Block1Data* _data1_);
static void block1_data_unref (void * _userdata_);
static SetupDictCellRenderer* setup_dict_cell_renderer_new (void);
static SetupDictCellRenderer* setup_dict_cell_renderer_construct (GType object_type);
static GType setup_dict_cell_renderer_get_type (void) G_GNUC_CONST G_GNUC_UNUSED;
static void __lambda2_ (Block1Data* _data1_);
static void setup_populate_shortcut_treeview (Setup* self, KkcInputMode input_mode);
static void ___lambda2__gtk_tree_selection_changed (GtkTreeSelection* _sender, gpointer self);
static SetupKeyEventCellRenderer* setup_key_event_cell_renderer_new (void);
static SetupKeyEventCellRenderer* setup_key_event_cell_renderer_construct (GType object_type);
static GType setup_key_event_cell_renderer_get_type (void) G_GNUC_CONST G_GNUC_UNUSED;
static void setup_accel_edited (Setup* self, const gchar* path_string, guint keyval, GdkModifierType modifiers, guint keycode);
static void _setup_accel_edited_gtk_cell_renderer_accel_accel_edited (GtkCellRendererAccel* _sender, const gchar* path_string, guint accel_key, GdkModifierType accel_mods, guint hardware_keycode, gpointer self);
static void setup_accel_cleared (Setup* self, const gchar* path_string);
static void _setup_accel_cleared_gtk_cell_renderer_accel_accel_cleared (GtkCellRendererAccel* _sender, const gchar* path_string, gpointer self);
static void __lambda3_ (Block1Data* _data1_);
static void ___lambda3__gtk_tree_selection_changed (GtkTreeSelection* _sender, gpointer self);
static void setup_add_shortcut (Setup* self);
static void _setup_add_shortcut_gtk_tool_button_clicked (GtkToolButton* _sender, gpointer self);
static void setup_remove_shortcut (Setup* self);
static void _setup_remove_shortcut_gtk_tool_button_clicked (GtkToolButton* _sender, gpointer self);
static void __lambda4_ (Setup* self);
static void ___lambda4__gtk_toggle_button_toggled (GtkToggleButton* _sender, gpointer self);
static void setup_load (Setup* self);
static void setup_add_dict (Setup* self);
static void _setup_add_dict_gtk_tool_button_clicked (GtkToolButton* _sender, gpointer self);
static void setup_remove_dict (Setup* self);
static void _setup_remove_dict_gtk_tool_button_clicked (GtkToolButton* _sender, gpointer self);
static void setup_up_dict (Setup* self);
static void _setup_up_dict_gtk_tool_button_clicked (GtkToolButton* _sender, gpointer self);
static void setup_down_dict (Setup* self);
static void _setup_down_dict_gtk_tool_button_clicked (GtkToolButton* _sender, gpointer self);
static void __lambda9_ (Block1Data* _data1_);
static void ___lambda9__gtk_tree_selection_changed (GtkTreeSelection* _sender, gpointer self);
static gchar* setup_combobox_get_active_string (Setup* self, GtkComboBox* combo, gint column);
static gboolean _vala_uint_array_contains (guint* stack, int stack_length, guint needle);
static void _gtk_tree_path_free0_ (gpointer var);
static void _g_list_free__gtk_tree_path_free0_ (GList* self);
static void setup_populate_dictionaries_treeview (Setup* self);
static void setup_populate_available_dictionaries_treeview (Setup* self);
static void _vala_KkcKeymapEntry_array_free (KkcKeymapEntry* array, gint array_length);
static void setup_save_dictionaries (Setup* self, const gchar* name);
static void setup_load_spinbutton (Setup* self, const gchar* name, GtkSpinButton* spin);
static Block2Data* block2_data_ref (Block2Data* _data2_);
static void block2_data_unref (void * _userdata_);
static void __lambda8_ (Block2Data* _data2_);
static GVariant* _variant_new1 (gint value);
static void ___lambda8__gtk_spin_button_value_changed (GtkSpinButton* _sender, gpointer self);
static void setup_load_togglebutton (Setup* self, const gchar* name, GtkToggleButton* toggle);
static Block3Data* block3_data_ref (Block3Data* _data3_);
static void block3_data_unref (void * _userdata_);
static void __lambda7_ (Block3Data* _data3_);
static GVariant* _variant_new2 (gboolean value);
static void ___lambda7__gtk_toggle_button_toggled (GtkToggleButton* _sender, gpointer self);
static void setup_load_combobox (Setup* self, const gchar* name, GtkComboBox* combo, gint column);
static Block4Data* block4_data_ref (Block4Data* _data4_);
static void block4_data_unref (void * _userdata_);
static void __lambda6_ (Block4Data* _data4_);
static void setup_save_combobox (Setup* self, const gchar* name, GtkComboBox* combo, gint column);
static void ___lambda6__gtk_combo_box_changed (GtkComboBox* _sender, gpointer self);
static void setup_load_combobox_string (Setup* self, const gchar* name, GtkComboBox* combo, gint column);
static Block5Data* block5_data_ref (Block5Data* _data5_);
static void block5_data_unref (void * _userdata_);
static void __lambda5_ (Block5Data* _data5_);
static void setup_save_combobox_string (Setup* self, const gchar* name, GtkComboBox* combo, gint column);
static void ___lambda5__gtk_combo_box_changed (GtkComboBox* _sender, gpointer self);
static void setup_select_shortcut_section (Setup* self, KkcInputMode input_mode);
static GVariant* _variant_new3 (gchar** value, gint value_length1);
static GVariant* _variant_new4 (gint value);
static GVariant* _variant_new5 (const gchar* value);
void setup_run (Setup* self);
gint setup_main (gchar** args, int args_length1);
#define SETUP_DICT_CELL_RENDERER_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), SETUP_TYPE_DICT_CELL_RENDERER, SetupDictCellRendererPrivate))
enum  {
	SETUP_DICT_CELL_RENDERER_DUMMY_PROPERTY,
	SETUP_DICT_CELL_RENDERER_METADATA
};
static DictionaryMetadata* setup_dict_cell_renderer_get_metadata (SetupDictCellRenderer* self);
static void setup_dict_cell_renderer_set_metadata (SetupDictCellRenderer* self, DictionaryMetadata* value);
static void setup_dict_cell_renderer_finalize (GObject* obj);
static void _vala_setup_dict_cell_renderer_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec);
static void _vala_setup_dict_cell_renderer_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec);
#define SETUP_KEY_EVENT_CELL_RENDERER_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), SETUP_TYPE_KEY_EVENT_CELL_RENDERER, SetupKeyEventCellRendererPrivate))
enum  {
	SETUP_KEY_EVENT_CELL_RENDERER_DUMMY_PROPERTY,
	SETUP_KEY_EVENT_CELL_RENDERER_EVENT
};
static KkcKeyEvent* setup_key_event_cell_renderer_get_event (SetupKeyEventCellRenderer* self);
static void setup_key_event_cell_renderer_set_event (SetupKeyEventCellRenderer* self, KkcKeyEvent* value);
static void setup_key_event_cell_renderer_finalize (GObject* obj);
static void _vala_setup_key_event_cell_renderer_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec);
static void _vala_setup_key_event_cell_renderer_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec);
static void setup_finalize (GObject* obj);
static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func);
static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func);

static const guint SETUP_IGNORED_KEYVALS[2] = {KKC_KEYSYMS_BackSpace, KKC_KEYSYMS_Escape};

static Block1Data* block1_data_ref (Block1Data* _data1_) {
	g_atomic_int_inc (&_data1_->_ref_count_);
	return _data1_;
}


static void block1_data_unref (void * _userdata_) {
	Block1Data* _data1_;
	_data1_ = (Block1Data*) _userdata_;
	if (g_atomic_int_dec_and_test (&_data1_->_ref_count_)) {
		Setup * self;
		self = _data1_->self;
		_g_object_unref0 (_data1_->dictionaries_selection);
		_g_object_unref0 (_data1_->shortcut_selection);
		_g_object_unref0 (_data1_->input_mode_selection);
		_g_object_unref0 (_data1_->down_dict_toolbutton);
		_g_object_unref0 (_data1_->up_dict_toolbutton);
		_g_object_unref0 (_data1_->remove_dict_toolbutton);
		_g_object_unref0 (self);
		g_slice_free (Block1Data, _data1_);
	}
}


static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


static void __lambda2_ (Block1Data* _data1_) {
	Setup * self;
	GtkTreeIter iter = {0};
	GtkTreeModel* _model = NULL;
	GtkTreeSelection* _tmp0_;
	GtkTreeModel* _tmp1_ = NULL;
	GtkTreeIter _tmp2_ = {0};
	gboolean _tmp3_ = FALSE;
	GtkTreeModel* _tmp4_;
	self = _data1_->self;
	_tmp0_ = _data1_->input_mode_selection;
	_tmp3_ = gtk_tree_selection_get_selected (_tmp0_, &_tmp1_, &_tmp2_);
	_g_object_unref0 (_model);
	_tmp4_ = _g_object_ref0 (_tmp1_);
	_model = _tmp4_;
	iter = _tmp2_;
	if (_tmp3_) {
		gint input_mode = 0;
		GtkTreeModel* _tmp5_;
		GtkTreeIter _tmp6_;
		gint _tmp7_;
		_tmp5_ = _model;
		_tmp6_ = iter;
		gtk_tree_model_get (_tmp5_, &_tmp6_, 1, &input_mode, -1, -1);
		_tmp7_ = input_mode;
		setup_populate_shortcut_treeview (self, (KkcInputMode) _tmp7_);
	}
	_g_object_unref0 (_model);
}


static void ___lambda2__gtk_tree_selection_changed (GtkTreeSelection* _sender, gpointer self) {
	__lambda2_ (self);
}


static void _setup_accel_edited_gtk_cell_renderer_accel_accel_edited (GtkCellRendererAccel* _sender, const gchar* path_string, guint accel_key, GdkModifierType accel_mods, guint hardware_keycode, gpointer self) {
	setup_accel_edited (self, path_string, accel_key, accel_mods, hardware_keycode);
}


static void _setup_accel_cleared_gtk_cell_renderer_accel_accel_cleared (GtkCellRendererAccel* _sender, const gchar* path_string, gpointer self) {
	setup_accel_cleared (self, path_string);
}


static void __lambda3_ (Block1Data* _data1_) {
	Setup * self;
	GtkTreeSelection* _tmp0_;
	gint _tmp1_ = 0;
	gint count;
	gint _tmp2_;
	self = _data1_->self;
	_tmp0_ = _data1_->shortcut_selection;
	_tmp1_ = gtk_tree_selection_count_selected_rows (_tmp0_);
	count = _tmp1_;
	_tmp2_ = count;
	if (_tmp2_ > 0) {
		GtkToolButton* _tmp3_;
		_tmp3_ = self->priv->remove_shortcut_toolbutton;
		gtk_widget_set_sensitive ((GtkWidget*) _tmp3_, TRUE);
	} else {
		gint _tmp4_;
		_tmp4_ = count;
		if (_tmp4_ == 0) {
			GtkToolButton* _tmp5_;
			_tmp5_ = self->priv->remove_shortcut_toolbutton;
			gtk_widget_set_sensitive ((GtkWidget*) _tmp5_, FALSE);
		}
	}
}


static void ___lambda3__gtk_tree_selection_changed (GtkTreeSelection* _sender, gpointer self) {
	__lambda3_ (self);
}


static void _setup_add_shortcut_gtk_tool_button_clicked (GtkToolButton* _sender, gpointer self) {
	setup_add_shortcut (self);
}


static void _setup_remove_shortcut_gtk_tool_button_clicked (GtkToolButton* _sender, gpointer self) {
	setup_remove_shortcut (self);
}


static void __lambda4_ (Setup* self) {
	GtkComboBox* _tmp0_;
	GtkCheckButton* _tmp1_;
	gboolean _tmp2_ = FALSE;
	_tmp0_ = self->priv->keymap_combobox;
	_tmp1_ = self->priv->use_custom_keymap_checkbutton;
	_tmp2_ = gtk_toggle_button_get_active ((GtkToggleButton*) _tmp1_);
	gtk_widget_set_sensitive ((GtkWidget*) _tmp0_, _tmp2_);
}


static void ___lambda4__gtk_toggle_button_toggled (GtkToggleButton* _sender, gpointer self) {
	__lambda4_ (self);
}


static void _setup_add_dict_gtk_tool_button_clicked (GtkToolButton* _sender, gpointer self) {
	setup_add_dict (self);
}


static void _setup_remove_dict_gtk_tool_button_clicked (GtkToolButton* _sender, gpointer self) {
	setup_remove_dict (self);
}


static void _setup_up_dict_gtk_tool_button_clicked (GtkToolButton* _sender, gpointer self) {
	setup_up_dict (self);
}


static void _setup_down_dict_gtk_tool_button_clicked (GtkToolButton* _sender, gpointer self) {
	setup_down_dict (self);
}


static void __lambda9_ (Block1Data* _data1_) {
	Setup * self;
	gint _tmp0_ = 0;
	gint count;
	gint _tmp1_;
	self = _data1_->self;
	_tmp0_ = gtk_tree_selection_count_selected_rows (_data1_->dictionaries_selection);
	count = _tmp0_;
	_tmp1_ = count;
	if (_tmp1_ > 0) {
		GtkToolButton* _tmp2_;
		GtkTreeModel* _model = NULL;
		GtkTreeIter iter = {0};
		GtkTreeModel* _tmp3_ = NULL;
		GtkTreeIter _tmp4_ = {0};
		gboolean _tmp5_ = FALSE;
		GtkTreeModel* _tmp6_;
		_tmp2_ = _data1_->remove_dict_toolbutton;
		gtk_widget_set_sensitive ((GtkWidget*) _tmp2_, TRUE);
		_tmp5_ = gtk_tree_selection_get_selected (_data1_->dictionaries_selection, &_tmp3_, &_tmp4_);
		_g_object_unref0 (_model);
		_tmp6_ = _g_object_ref0 (_tmp3_);
		_model = _tmp6_;
		iter = _tmp4_;
		if (_tmp5_) {
			GtkTreeIter _tmp7_;
			GtkTreeIter prev;
			GtkToolButton* _tmp8_;
			GtkTreeModel* _tmp9_;
			gboolean _tmp10_ = FALSE;
			GtkTreeIter _tmp11_;
			GtkTreeIter next;
			GtkToolButton* _tmp12_;
			GtkTreeModel* _tmp13_;
			gboolean _tmp14_ = FALSE;
			_tmp7_ = iter;
			prev = _tmp7_;
			_tmp8_ = _data1_->up_dict_toolbutton;
			_tmp9_ = _model;
			_tmp10_ = gtk_tree_model_iter_previous (_tmp9_, &prev);
			gtk_widget_set_sensitive ((GtkWidget*) _tmp8_, _tmp10_);
			_tmp11_ = iter;
			next = _tmp11_;
			_tmp12_ = _data1_->down_dict_toolbutton;
			_tmp13_ = _model;
			_tmp14_ = gtk_tree_model_iter_next (_tmp13_, &next);
			gtk_widget_set_sensitive ((GtkWidget*) _tmp12_, _tmp14_);
		}
		_g_object_unref0 (_model);
	} else {
		gint _tmp15_;
		_tmp15_ = count;
		if (_tmp15_ == 0) {
			GtkToolButton* _tmp16_;
			GtkToolButton* _tmp17_;
			GtkToolButton* _tmp18_;
			_tmp16_ = _data1_->remove_dict_toolbutton;
			gtk_widget_set_sensitive ((GtkWidget*) _tmp16_, FALSE);
			_tmp17_ = _data1_->up_dict_toolbutton;
			gtk_widget_set_sensitive ((GtkWidget*) _tmp17_, FALSE);
			_tmp18_ = _data1_->down_dict_toolbutton;
			gtk_widget_set_sensitive ((GtkWidget*) _tmp18_, FALSE);
		}
	}
}


static void ___lambda9__gtk_tree_selection_changed (GtkTreeSelection* _sender, gpointer self) {
	__lambda9_ (self);
}


Setup* setup_construct (GType object_type, Preferences* preferences) {
	Setup * self = NULL;
	Block1Data* _data1_;
	Preferences* _tmp0_;
	Preferences* _tmp1_;
	GtkBuilder* _tmp2_;
	GtkBuilder* builder;
	GObject* object = NULL;
	GObject* _tmp4_ = NULL;
	GObject* _tmp5_;
	GObject* _tmp6_;
	GObject* _tmp7_;
	GtkDialog* _tmp8_;
	GObject* _tmp9_ = NULL;
	GObject* _tmp10_;
	GObject* _tmp11_;
	GObject* _tmp12_;
	GtkTreeView* _tmp13_;
	GObject* _tmp14_ = NULL;
	GObject* _tmp15_;
	GObject* _tmp16_;
	GObject* _tmp17_;
	GtkTreeView* _tmp18_;
	GObject* _tmp19_ = NULL;
	GObject* _tmp20_;
	GObject* _tmp21_;
	GObject* _tmp22_;
	GtkComboBox* _tmp23_;
	GObject* _tmp24_ = NULL;
	GObject* _tmp25_;
	GObject* _tmp26_;
	GObject* _tmp27_;
	GtkCheckButton* _tmp28_;
	GObject* _tmp29_ = NULL;
	GObject* _tmp30_;
	GObject* _tmp31_;
	GObject* _tmp32_;
	GtkCheckButton* _tmp33_;
	GObject* _tmp34_ = NULL;
	GObject* _tmp35_;
	GObject* _tmp36_;
	GObject* _tmp37_;
	GtkComboBox* _tmp38_;
	GObject* _tmp39_ = NULL;
	GObject* _tmp40_;
	GObject* _tmp41_;
	GObject* _tmp42_;
	GtkSpinButton* _tmp43_;
	GObject* _tmp44_ = NULL;
	GObject* _tmp45_;
	GObject* _tmp46_;
	GObject* _tmp47_;
	GtkSpinButton* _tmp48_;
	GObject* _tmp49_ = NULL;
	GObject* _tmp50_;
	GObject* _tmp51_;
	GObject* _tmp52_;
	GtkCheckButton* _tmp53_;
	GObject* _tmp54_ = NULL;
	GObject* _tmp55_;
	GObject* _tmp56_;
	GObject* _tmp57_;
	GtkComboBox* _tmp58_;
	GObject* _tmp59_ = NULL;
	GObject* _tmp60_;
	GObject* _tmp61_;
	GObject* _tmp62_;
	GtkComboBox* _tmp63_;
	GObject* _tmp64_ = NULL;
	GObject* _tmp65_;
	GObject* _tmp66_;
	GObject* _tmp67_;
	GtkToolButton* _tmp68_;
	GtkToolButton* add_dict_toolbutton;
	GObject* _tmp69_ = NULL;
	GObject* _tmp70_;
	GObject* _tmp71_;
	GObject* _tmp72_;
	GtkToolButton* _tmp73_;
	GObject* _tmp74_ = NULL;
	GObject* _tmp75_;
	GObject* _tmp76_;
	GObject* _tmp77_;
	GtkToolButton* _tmp78_;
	GObject* _tmp79_ = NULL;
	GObject* _tmp80_;
	GObject* _tmp81_;
	GObject* _tmp82_;
	GtkToolButton* _tmp83_;
	GObject* _tmp84_ = NULL;
	GObject* _tmp85_;
	GObject* _tmp86_;
	GObject* _tmp87_;
	GtkDialog* _tmp88_;
	GObject* _tmp89_ = NULL;
	GObject* _tmp90_;
	GObject* _tmp91_;
	GObject* _tmp92_;
	GtkTreeView* _tmp93_;
	GObject* _tmp94_ = NULL;
	GObject* _tmp95_;
	GObject* _tmp96_;
	GObject* _tmp97_;
	GtkTreeView* _tmp98_;
	GObject* _tmp99_ = NULL;
	GObject* _tmp100_;
	GObject* _tmp101_;
	GObject* _tmp102_;
	GtkToolButton* _tmp103_;
	GObject* _tmp104_ = NULL;
	GObject* _tmp105_;
	GObject* _tmp106_;
	GObject* _tmp107_;
	GtkToolButton* _tmp108_;
	GObject* _tmp109_ = NULL;
	GObject* _tmp110_;
	GObject* _tmp111_;
	GObject* _tmp112_;
	GtkDialog* _tmp113_;
	GObject* _tmp114_ = NULL;
	GObject* _tmp115_;
	GObject* _tmp116_;
	GObject* _tmp117_;
	GtkComboBox* _tmp118_;
	GtkSpinButton* _tmp119_;
	GtkSpinButton* _tmp120_;
	GtkSpinButton* _tmp121_;
	GtkSpinButton* _tmp122_;
	GtkListStore* model = NULL;
	GtkCellRenderer* renderer = NULL;
	GtkTreeViewColumn* column = NULL;
	GtkListStore* _tmp123_;
	GtkTreeView* _tmp124_;
	GtkListStore* _tmp125_;
	SetupDictCellRenderer* _tmp126_;
	GtkCellRenderer* _tmp127_;
	GtkTreeViewColumn* _tmp128_;
	GtkTreeView* _tmp129_;
	GtkTreeViewColumn* _tmp130_;
	GtkListStore* _tmp131_;
	GtkTreeView* _tmp132_;
	GtkListStore* _tmp133_;
	SetupDictCellRenderer* _tmp134_;
	GtkCellRenderer* _tmp135_;
	GtkTreeViewColumn* _tmp136_;
	GtkTreeView* _tmp137_;
	GtkTreeViewColumn* _tmp138_;
	GtkCellRendererText* _tmp139_;
	GtkComboBox* _tmp140_;
	GtkCellRenderer* _tmp141_;
	GtkComboBox* _tmp142_;
	GtkCellRenderer* _tmp143_;
	GtkCellRendererText* _tmp144_;
	GtkComboBox* _tmp145_;
	GtkCellRenderer* _tmp146_;
	GtkComboBox* _tmp147_;
	GtkCellRenderer* _tmp148_;
	GtkCellRendererText* _tmp149_;
	GtkCellRenderer* _tmp150_;
	GtkTreeViewColumn* _tmp151_;
	GtkTreeView* _tmp152_;
	GtkTreeViewColumn* _tmp153_;
	GtkTreeView* _tmp154_;
	GtkTreeSelection* _tmp155_ = NULL;
	GtkTreeSelection* _tmp156_;
	GtkTreeSelection* _tmp157_;
	GtkListStore* _tmp158_;
	GtkListStore* _tmp159_;
	GtkTreeView* _tmp160_;
	GtkListStore* _tmp161_;
	GtkCellRendererText* _tmp162_;
	GtkCellRenderer* _tmp163_;
	GtkTreeViewColumn* _tmp164_;
	GtkTreeView* _tmp165_;
	GtkTreeViewColumn* _tmp166_;
	SetupKeyEventCellRenderer* _tmp167_;
	SetupKeyEventCellRenderer* accel_renderer;
	SetupKeyEventCellRenderer* _tmp168_;
	SetupKeyEventCellRenderer* _tmp169_;
	GtkTreeViewColumn* _tmp170_;
	GtkTreeView* _tmp171_;
	GtkTreeViewColumn* _tmp172_;
	SetupKeyEventCellRenderer* _tmp173_;
	SetupKeyEventCellRenderer* _tmp174_;
	GtkTreeView* _tmp175_;
	GtkTreeSelection* _tmp176_ = NULL;
	GtkTreeSelection* _tmp177_;
	GtkTreeSelection* _tmp178_;
	GtkListStore* _tmp179_;
	GtkListStore* _tmp180_;
	GtkComboBox* _tmp181_;
	GtkListStore* _tmp182_;
	gint _tmp183_ = 0;
	gchar** _tmp184_ = NULL;
	gchar** commands;
	gint commands_length1;
	gint _commands_size_;
	gchar** _tmp185_;
	gint _tmp185__length1;
	GtkComboBox* _tmp195_;
	GtkCellRendererText* _tmp196_;
	GtkComboBox* _tmp197_;
	GtkCellRenderer* _tmp198_;
	GtkComboBox* _tmp199_;
	GtkCellRenderer* _tmp200_;
	GtkToolButton* _tmp201_;
	GtkToolButton* _tmp202_;
	GtkListStore* _tmp203_;
	GtkListStore* _tmp204_;
	GtkComboBox* _tmp205_;
	GtkListStore* _tmp206_;
	gint _tmp207_ = 0;
	KkcRuleMetadata** _tmp208_ = NULL;
	KkcRuleMetadata** rules;
	gint rules_length1;
	gint _rules_size_;
	KkcRuleMetadata** _tmp209_;
	gint _tmp209__length1;
	GtkCellRendererText* _tmp224_;
	GtkComboBox* _tmp225_;
	GtkCellRenderer* _tmp226_;
	GtkComboBox* _tmp227_;
	GtkCellRenderer* _tmp228_;
	GtkCellRendererText* _tmp229_;
	GtkComboBox* _tmp230_;
	GtkCellRenderer* _tmp231_;
	GtkComboBox* _tmp232_;
	GtkCellRenderer* _tmp233_;
	GtkCheckButton* _tmp234_;
	GtkToolButton* _tmp235_;
	GtkToolButton* _tmp236_;
	GtkToolButton* _tmp237_;
	GtkToolButton* _tmp238_;
	GtkTreeView* _tmp239_;
	GtkTreeSelection* _tmp240_ = NULL;
	GtkTreeSelection* _tmp241_;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (preferences != NULL, NULL);
	_data1_ = g_slice_new0 (Block1Data);
	_data1_->_ref_count_ = 1;
	self = (Setup*) g_object_new (object_type, NULL);
	_data1_->self = g_object_ref (self);
	_tmp0_ = preferences;
	_tmp1_ = _g_object_ref0 (_tmp0_);
	_g_object_unref0 (self->priv->preferences);
	self->priv->preferences = _tmp1_;
	_tmp2_ = gtk_builder_new ();
	builder = _tmp2_;
	gtk_builder_set_translation_domain (builder, "ibus-kkc");
	{
		gtk_builder_add_from_resource (builder, "/org/freedesktop/ibus/engine/kkc/preferences.ui", &_inner_error_);
		if (_inner_error_ != NULL) {
			goto __catch0_g_error;
		}
	}
	goto __finally0;
	__catch0_g_error:
	{
		GError* e = NULL;
		const gchar* _tmp3_;
		e = _inner_error_;
		_inner_error_ = NULL;
		_tmp3_ = e->message;
		g_error ("setup.vala:62: can't load ui from resource: %s", _tmp3_);
		_g_error_free0 (e);
	}
	__finally0:
	if (_inner_error_ != NULL) {
		_g_object_unref0 (builder);
		block1_data_unref (_data1_);
		_data1_ = NULL;
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return NULL;
	}
	_tmp4_ = gtk_builder_get_object (builder, "dialog");
	_tmp5_ = _g_object_ref0 (_tmp4_);
	_g_object_unref0 (object);
	object = _tmp5_;
	_tmp6_ = object;
	_vala_assert (_tmp6_ != NULL, "object != null");
	_tmp7_ = object;
	_tmp8_ = _g_object_ref0 (G_TYPE_CHECK_INSTANCE_CAST (_tmp7_, GTK_TYPE_DIALOG, GtkDialog));
	_g_object_unref0 (self->priv->dialog);
	self->priv->dialog = _tmp8_;
	_tmp9_ = gtk_builder_get_object (builder, "dictionaries_treeview");
	_tmp10_ = _g_object_ref0 (_tmp9_);
	_g_object_unref0 (object);
	object = _tmp10_;
	_tmp11_ = object;
	_vala_assert (_tmp11_ != NULL, "object != null");
	_tmp12_ = object;
	_tmp13_ = _g_object_ref0 (G_TYPE_CHECK_INSTANCE_CAST (_tmp12_, GTK_TYPE_TREE_VIEW, GtkTreeView));
	_g_object_unref0 (self->priv->dictionaries_treeview);
	self->priv->dictionaries_treeview = _tmp13_;
	_tmp14_ = gtk_builder_get_object (builder, "available_dictionaries_treeview");
	_tmp15_ = _g_object_ref0 (_tmp14_);
	_g_object_unref0 (object);
	object = _tmp15_;
	_tmp16_ = object;
	_vala_assert (_tmp16_ != NULL, "object != null");
	_tmp17_ = object;
	_tmp18_ = _g_object_ref0 (G_TYPE_CHECK_INSTANCE_CAST (_tmp17_, GTK_TYPE_TREE_VIEW, GtkTreeView));
	_g_object_unref0 (self->priv->available_dictionaries_treeview);
	self->priv->available_dictionaries_treeview = _tmp18_;
	_tmp19_ = gtk_builder_get_object (builder, "punctuation_style_combobox");
	_tmp20_ = _g_object_ref0 (_tmp19_);
	_g_object_unref0 (object);
	object = _tmp20_;
	_tmp21_ = object;
	_vala_assert (_tmp21_ != NULL, "object != null");
	_tmp22_ = object;
	_tmp23_ = _g_object_ref0 (G_TYPE_CHECK_INSTANCE_CAST (_tmp22_, GTK_TYPE_COMBO_BOX, GtkComboBox));
	_g_object_unref0 (self->priv->punctuation_style_combobox);
	self->priv->punctuation_style_combobox = _tmp23_;
	_tmp24_ = gtk_builder_get_object (builder, "auto_correct_checkbutton");
	_tmp25_ = _g_object_ref0 (_tmp24_);
	_g_object_unref0 (object);
	object = _tmp25_;
	_tmp26_ = object;
	_vala_assert (_tmp26_ != NULL, "object != null");
	_tmp27_ = object;
	_tmp28_ = _g_object_ref0 (G_TYPE_CHECK_INSTANCE_CAST (_tmp27_, GTK_TYPE_CHECK_BUTTON, GtkCheckButton));
	_g_object_unref0 (self->priv->auto_correct_checkbutton);
	self->priv->auto_correct_checkbutton = _tmp28_;
	_tmp29_ = gtk_builder_get_object (builder, "use_custom_keymap_checkbutton");
	_tmp30_ = _g_object_ref0 (_tmp29_);
	_g_object_unref0 (object);
	object = _tmp30_;
	_tmp31_ = object;
	_vala_assert (_tmp31_ != NULL, "object != null");
	_tmp32_ = object;
	_tmp33_ = _g_object_ref0 (G_TYPE_CHECK_INSTANCE_CAST (_tmp32_, GTK_TYPE_CHECK_BUTTON, GtkCheckButton));
	_g_object_unref0 (self->priv->use_custom_keymap_checkbutton);
	self->priv->use_custom_keymap_checkbutton = _tmp33_;
	_tmp34_ = gtk_builder_get_object (builder, "keymap_combobox");
	_tmp35_ = _g_object_ref0 (_tmp34_);
	_g_object_unref0 (object);
	object = _tmp35_;
	_tmp36_ = object;
	_vala_assert (_tmp36_ != NULL, "object != null");
	_tmp37_ = object;
	_tmp38_ = _g_object_ref0 (G_TYPE_CHECK_INSTANCE_CAST (_tmp37_, GTK_TYPE_COMBO_BOX, GtkComboBox));
	_g_object_unref0 (self->priv->keymap_combobox);
	self->priv->keymap_combobox = _tmp38_;
	_tmp39_ = gtk_builder_get_object (builder, "page_size_spinbutton");
	_tmp40_ = _g_object_ref0 (_tmp39_);
	_g_object_unref0 (object);
	object = _tmp40_;
	_tmp41_ = object;
	_vala_assert (_tmp41_ != NULL, "object != null");
	_tmp42_ = object;
	_tmp43_ = _g_object_ref0 (G_TYPE_CHECK_INSTANCE_CAST (_tmp42_, GTK_TYPE_SPIN_BUTTON, GtkSpinButton));
	_g_object_unref0 (self->priv->page_size_spinbutton);
	self->priv->page_size_spinbutton = _tmp43_;
	_tmp44_ = gtk_builder_get_object (builder, "pagination_start_spinbutton");
	_tmp45_ = _g_object_ref0 (_tmp44_);
	_g_object_unref0 (object);
	object = _tmp45_;
	_tmp46_ = object;
	_vala_assert (_tmp46_ != NULL, "object != null");
	_tmp47_ = object;
	_tmp48_ = _g_object_ref0 (G_TYPE_CHECK_INSTANCE_CAST (_tmp47_, GTK_TYPE_SPIN_BUTTON, GtkSpinButton));
	_g_object_unref0 (self->priv->pagination_start_spinbutton);
	self->priv->pagination_start_spinbutton = _tmp48_;
	_tmp49_ = gtk_builder_get_object (builder, "show_annotation_checkbutton");
	_tmp50_ = _g_object_ref0 (_tmp49_);
	_g_object_unref0 (object);
	object = _tmp50_;
	_tmp51_ = object;
	_vala_assert (_tmp51_ != NULL, "object != null");
	_tmp52_ = object;
	_tmp53_ = _g_object_ref0 (G_TYPE_CHECK_INSTANCE_CAST (_tmp52_, GTK_TYPE_CHECK_BUTTON, GtkCheckButton));
	_g_object_unref0 (self->priv->show_annotation_checkbutton);
	self->priv->show_annotation_checkbutton = _tmp53_;
	_tmp54_ = gtk_builder_get_object (builder, "initial_input_mode_combobox");
	_tmp55_ = _g_object_ref0 (_tmp54_);
	_g_object_unref0 (object);
	object = _tmp55_;
	_tmp56_ = object;
	_vala_assert (_tmp56_ != NULL, "object != null");
	_tmp57_ = object;
	_tmp58_ = _g_object_ref0 (G_TYPE_CHECK_INSTANCE_CAST (_tmp57_, GTK_TYPE_COMBO_BOX, GtkComboBox));
	_g_object_unref0 (self->priv->initial_input_mode_combobox);
	self->priv->initial_input_mode_combobox = _tmp58_;
	_tmp59_ = gtk_builder_get_object (builder, "typing_rule_combobox");
	_tmp60_ = _g_object_ref0 (_tmp59_);
	_g_object_unref0 (object);
	object = _tmp60_;
	_tmp61_ = object;
	_vala_assert (_tmp61_ != NULL, "object != null");
	_tmp62_ = object;
	_tmp63_ = _g_object_ref0 (G_TYPE_CHECK_INSTANCE_CAST (_tmp62_, GTK_TYPE_COMBO_BOX, GtkComboBox));
	_g_object_unref0 (self->priv->typing_rule_combobox);
	self->priv->typing_rule_combobox = _tmp63_;
	_tmp64_ = gtk_builder_get_object (builder, "add_dict_toolbutton");
	_tmp65_ = _g_object_ref0 (_tmp64_);
	_g_object_unref0 (object);
	object = _tmp65_;
	_tmp66_ = object;
	_vala_assert (_tmp66_ != NULL, "object != null");
	_tmp67_ = object;
	_tmp68_ = _g_object_ref0 (G_TYPE_CHECK_INSTANCE_CAST (_tmp67_, GTK_TYPE_TOOL_BUTTON, GtkToolButton));
	add_dict_toolbutton = _tmp68_;
	_tmp69_ = gtk_builder_get_object (builder, "remove_dict_toolbutton");
	_tmp70_ = _g_object_ref0 (_tmp69_);
	_g_object_unref0 (object);
	object = _tmp70_;
	_tmp71_ = object;
	_vala_assert (_tmp71_ != NULL, "object != null");
	_tmp72_ = object;
	_tmp73_ = _g_object_ref0 (G_TYPE_CHECK_INSTANCE_CAST (_tmp72_, GTK_TYPE_TOOL_BUTTON, GtkToolButton));
	_data1_->remove_dict_toolbutton = _tmp73_;
	_tmp74_ = gtk_builder_get_object (builder, "up_dict_toolbutton");
	_tmp75_ = _g_object_ref0 (_tmp74_);
	_g_object_unref0 (object);
	object = _tmp75_;
	_tmp76_ = object;
	_vala_assert (_tmp76_ != NULL, "object != null");
	_tmp77_ = object;
	_tmp78_ = _g_object_ref0 (G_TYPE_CHECK_INSTANCE_CAST (_tmp77_, GTK_TYPE_TOOL_BUTTON, GtkToolButton));
	_data1_->up_dict_toolbutton = _tmp78_;
	_tmp79_ = gtk_builder_get_object (builder, "down_dict_toolbutton");
	_tmp80_ = _g_object_ref0 (_tmp79_);
	_g_object_unref0 (object);
	object = _tmp80_;
	_tmp81_ = object;
	_vala_assert (_tmp81_ != NULL, "object != null");
	_tmp82_ = object;
	_tmp83_ = _g_object_ref0 (G_TYPE_CHECK_INSTANCE_CAST (_tmp82_, GTK_TYPE_TOOL_BUTTON, GtkToolButton));
	_data1_->down_dict_toolbutton = _tmp83_;
	_tmp84_ = gtk_builder_get_object (builder, "dict_dialog");
	_tmp85_ = _g_object_ref0 (_tmp84_);
	_g_object_unref0 (object);
	object = _tmp85_;
	_tmp86_ = object;
	_vala_assert (_tmp86_ != NULL, "object != null");
	_tmp87_ = object;
	_tmp88_ = _g_object_ref0 (G_TYPE_CHECK_INSTANCE_CAST (_tmp87_, GTK_TYPE_DIALOG, GtkDialog));
	_g_object_unref0 (self->priv->dict_dialog);
	self->priv->dict_dialog = _tmp88_;
	_tmp89_ = gtk_builder_get_object (builder, "input_mode_treeview");
	_tmp90_ = _g_object_ref0 (_tmp89_);
	_g_object_unref0 (object);
	object = _tmp90_;
	_tmp91_ = object;
	_vala_assert (_tmp91_ != NULL, "object != null");
	_tmp92_ = object;
	_tmp93_ = _g_object_ref0 (G_TYPE_CHECK_INSTANCE_CAST (_tmp92_, GTK_TYPE_TREE_VIEW, GtkTreeView));
	_g_object_unref0 (self->priv->input_mode_treeview);
	self->priv->input_mode_treeview = _tmp93_;
	_tmp94_ = gtk_builder_get_object (builder, "shortcut_treeview");
	_tmp95_ = _g_object_ref0 (_tmp94_);
	_g_object_unref0 (object);
	object = _tmp95_;
	_tmp96_ = object;
	_vala_assert (_tmp96_ != NULL, "object != null");
	_tmp97_ = object;
	_tmp98_ = _g_object_ref0 (G_TYPE_CHECK_INSTANCE_CAST (_tmp97_, GTK_TYPE_TREE_VIEW, GtkTreeView));
	_g_object_unref0 (self->priv->shortcut_treeview);
	self->priv->shortcut_treeview = _tmp98_;
	_tmp99_ = gtk_builder_get_object (builder, "add_shortcut_toolbutton");
	_tmp100_ = _g_object_ref0 (_tmp99_);
	_g_object_unref0 (object);
	object = _tmp100_;
	_tmp101_ = object;
	_vala_assert (_tmp101_ != NULL, "object != null");
	_tmp102_ = object;
	_tmp103_ = _g_object_ref0 (G_TYPE_CHECK_INSTANCE_CAST (_tmp102_, GTK_TYPE_TOOL_BUTTON, GtkToolButton));
	_g_object_unref0 (self->priv->add_shortcut_toolbutton);
	self->priv->add_shortcut_toolbutton = _tmp103_;
	_tmp104_ = gtk_builder_get_object (builder, "remove_shortcut_toolbutton");
	_tmp105_ = _g_object_ref0 (_tmp104_);
	_g_object_unref0 (object);
	object = _tmp105_;
	_tmp106_ = object;
	_vala_assert (_tmp106_ != NULL, "object != null");
	_tmp107_ = object;
	_tmp108_ = _g_object_ref0 (G_TYPE_CHECK_INSTANCE_CAST (_tmp107_, GTK_TYPE_TOOL_BUTTON, GtkToolButton));
	_g_object_unref0 (self->priv->remove_shortcut_toolbutton);
	self->priv->remove_shortcut_toolbutton = _tmp108_;
	_tmp109_ = gtk_builder_get_object (builder, "shortcut_dialog");
	_tmp110_ = _g_object_ref0 (_tmp109_);
	_g_object_unref0 (object);
	object = _tmp110_;
	_tmp111_ = object;
	_vala_assert (_tmp111_ != NULL, "object != null");
	_tmp112_ = object;
	_tmp113_ = _g_object_ref0 (G_TYPE_CHECK_INSTANCE_CAST (_tmp112_, GTK_TYPE_DIALOG, GtkDialog));
	_g_object_unref0 (self->priv->shortcut_dialog);
	self->priv->shortcut_dialog = _tmp113_;
	_tmp114_ = gtk_builder_get_object (builder, "shortcut_command_combobox");
	_tmp115_ = _g_object_ref0 (_tmp114_);
	_g_object_unref0 (object);
	object = _tmp115_;
	_tmp116_ = object;
	_vala_assert (_tmp116_ != NULL, "object != null");
	_tmp117_ = object;
	_tmp118_ = _g_object_ref0 (G_TYPE_CHECK_INSTANCE_CAST (_tmp117_, GTK_TYPE_COMBO_BOX, GtkComboBox));
	_g_object_unref0 (self->priv->shortcut_command_combobox);
	self->priv->shortcut_command_combobox = _tmp118_;
	_tmp119_ = self->priv->page_size_spinbutton;
	gtk_spin_button_set_range (_tmp119_, 7.0, 16.0);
	_tmp120_ = self->priv->page_size_spinbutton;
	gtk_spin_button_set_increments (_tmp120_, 1.0, 1.0);
	_tmp121_ = self->priv->pagination_start_spinbutton;
	gtk_spin_button_set_range (_tmp121_, 0.0, 7.0);
	_tmp122_ = self->priv->pagination_start_spinbutton;
	gtk_spin_button_set_increments (_tmp122_, 1.0, 1.0);
	_tmp123_ = gtk_list_store_new (2, TYPE_DICTIONARY_METADATA, G_TYPE_STRING);
	_g_object_unref0 (model);
	model = _tmp123_;
	_tmp124_ = self->priv->dictionaries_treeview;
	_tmp125_ = model;
	gtk_tree_view_set_model (_tmp124_, (GtkTreeModel*) _tmp125_);
	_tmp126_ = setup_dict_cell_renderer_new ();
	g_object_ref_sink (_tmp126_);
	_g_object_unref0 (renderer);
	renderer = (GtkCellRenderer*) _tmp126_;
	_tmp127_ = renderer;
	_tmp128_ = gtk_tree_view_column_new_with_attributes ("dict", _tmp127_, "metadata", 0, NULL);
	g_object_ref_sink (_tmp128_);
	_g_object_unref0 (column);
	column = _tmp128_;
	_tmp129_ = self->priv->dictionaries_treeview;
	_tmp130_ = column;
	gtk_tree_view_append_column (_tmp129_, _tmp130_);
	_tmp131_ = gtk_list_store_new (2, TYPE_DICTIONARY_METADATA, G_TYPE_STRING);
	_g_object_unref0 (model);
	model = _tmp131_;
	_tmp132_ = self->priv->available_dictionaries_treeview;
	_tmp133_ = model;
	gtk_tree_view_set_model (_tmp132_, (GtkTreeModel*) _tmp133_);
	_tmp134_ = setup_dict_cell_renderer_new ();
	g_object_ref_sink (_tmp134_);
	_g_object_unref0 (renderer);
	renderer = (GtkCellRenderer*) _tmp134_;
	_tmp135_ = renderer;
	_tmp136_ = gtk_tree_view_column_new_with_attributes ("dict", _tmp135_, "metadata", 0, NULL);
	g_object_ref_sink (_tmp136_);
	_g_object_unref0 (column);
	column = _tmp136_;
	_tmp137_ = self->priv->available_dictionaries_treeview;
	_tmp138_ = column;
	gtk_tree_view_append_column (_tmp137_, _tmp138_);
	_tmp139_ = (GtkCellRendererText*) gtk_cell_renderer_text_new ();
	g_object_ref_sink (_tmp139_);
	_g_object_unref0 (renderer);
	renderer = (GtkCellRenderer*) _tmp139_;
	_tmp140_ = self->priv->punctuation_style_combobox;
	_tmp141_ = renderer;
	gtk_cell_layout_pack_start ((GtkCellLayout*) _tmp140_, _tmp141_, FALSE);
	_tmp142_ = self->priv->punctuation_style_combobox;
	_tmp143_ = renderer;
	gtk_cell_layout_set_attributes ((GtkCellLayout*) _tmp142_, _tmp143_, "text", 0, NULL);
	_tmp144_ = (GtkCellRendererText*) gtk_cell_renderer_text_new ();
	g_object_ref_sink (_tmp144_);
	_g_object_unref0 (renderer);
	renderer = (GtkCellRenderer*) _tmp144_;
	_tmp145_ = self->priv->initial_input_mode_combobox;
	_tmp146_ = renderer;
	gtk_cell_layout_pack_start ((GtkCellLayout*) _tmp145_, _tmp146_, FALSE);
	_tmp147_ = self->priv->initial_input_mode_combobox;
	_tmp148_ = renderer;
	gtk_cell_layout_set_attributes ((GtkCellLayout*) _tmp147_, _tmp148_, "text", 0, NULL);
	_tmp149_ = (GtkCellRendererText*) gtk_cell_renderer_text_new ();
	g_object_ref_sink (_tmp149_);
	_g_object_unref0 (renderer);
	renderer = (GtkCellRenderer*) _tmp149_;
	_tmp150_ = renderer;
	_tmp151_ = gtk_tree_view_column_new_with_attributes ("Mode", _tmp150_, "text", 0, NULL);
	g_object_ref_sink (_tmp151_);
	_g_object_unref0 (column);
	column = _tmp151_;
	_tmp152_ = self->priv->input_mode_treeview;
	_tmp153_ = column;
	gtk_tree_view_append_column (_tmp152_, _tmp153_);
	_tmp154_ = self->priv->input_mode_treeview;
	_tmp155_ = gtk_tree_view_get_selection (_tmp154_);
	_tmp156_ = _g_object_ref0 (_tmp155_);
	_data1_->input_mode_selection = _tmp156_;
	_tmp157_ = _data1_->input_mode_selection;
	g_signal_connect_data (_tmp157_, "changed", (GCallback) ___lambda2__gtk_tree_selection_changed, block1_data_ref (_data1_), (GClosureNotify) block1_data_unref, 0);
	_tmp158_ = gtk_list_store_new (3, G_TYPE_STRING, KKC_TYPE_KEY_EVENT, G_TYPE_STRING);
	_g_object_unref0 (model);
	model = _tmp158_;
	_tmp159_ = model;
	gtk_tree_sortable_set_sort_column_id ((GtkTreeSortable*) _tmp159_, 0, GTK_SORT_ASCENDING);
	_tmp160_ = self->priv->shortcut_treeview;
	_tmp161_ = model;
	gtk_tree_view_set_model (_tmp160_, (GtkTreeModel*) _tmp161_);
	_tmp162_ = (GtkCellRendererText*) gtk_cell_renderer_text_new ();
	g_object_ref_sink (_tmp162_);
	_g_object_unref0 (renderer);
	renderer = (GtkCellRenderer*) _tmp162_;
	_tmp163_ = renderer;
	_tmp164_ = gtk_tree_view_column_new_with_attributes ("Command", _tmp163_, "text", 2, NULL);
	g_object_ref_sink (_tmp164_);
	_g_object_unref0 (column);
	column = _tmp164_;
	_tmp165_ = self->priv->shortcut_treeview;
	_tmp166_ = column;
	gtk_tree_view_append_column (_tmp165_, _tmp166_);
	_tmp167_ = setup_key_event_cell_renderer_new ();
	g_object_ref_sink (_tmp167_);
	accel_renderer = _tmp167_;
	_tmp168_ = accel_renderer;
	g_object_set ((GObject*) _tmp168_, "editable", TRUE, "accel-mode", GTK_CELL_RENDERER_ACCEL_MODE_OTHER, NULL, NULL);
	_tmp169_ = accel_renderer;
	_tmp170_ = gtk_tree_view_column_new_with_attributes ("Shortcut", (GtkCellRenderer*) _tmp169_, "event", 1, NULL);
	g_object_ref_sink (_tmp170_);
	_g_object_unref0 (column);
	column = _tmp170_;
	_tmp171_ = self->priv->shortcut_treeview;
	_tmp172_ = column;
	gtk_tree_view_append_column (_tmp171_, _tmp172_);
	_tmp173_ = accel_renderer;
	g_signal_connect_object ((GtkCellRendererAccel*) _tmp173_, "accel-edited", (GCallback) _setup_accel_edited_gtk_cell_renderer_accel_accel_edited, self, 0);
	_tmp174_ = accel_renderer;
	g_signal_connect_object ((GtkCellRendererAccel*) _tmp174_, "accel-cleared", (GCallback) _setup_accel_cleared_gtk_cell_renderer_accel_accel_cleared, self, 0);
	_tmp175_ = self->priv->shortcut_treeview;
	_tmp176_ = gtk_tree_view_get_selection (_tmp175_);
	_tmp177_ = _g_object_ref0 (_tmp176_);
	_data1_->shortcut_selection = _tmp177_;
	_tmp178_ = _data1_->shortcut_selection;
	g_signal_connect_data (_tmp178_, "changed", (GCallback) ___lambda3__gtk_tree_selection_changed, block1_data_ref (_data1_), (GClosureNotify) block1_data_unref, 0);
	_tmp179_ = gtk_list_store_new (2, G_TYPE_STRING, G_TYPE_STRING);
	_g_object_unref0 (model);
	model = _tmp179_;
	_tmp180_ = model;
	gtk_tree_sortable_set_sort_column_id ((GtkTreeSortable*) _tmp180_, 1, GTK_SORT_ASCENDING);
	_tmp181_ = self->priv->shortcut_command_combobox;
	_tmp182_ = model;
	gtk_combo_box_set_model (_tmp181_, (GtkTreeModel*) _tmp182_);
	_tmp184_ = kkc_keymap_commands (&_tmp183_);
	commands = _tmp184_;
	commands_length1 = _tmp183_;
	_commands_size_ = commands_length1;
	_tmp185_ = commands;
	_tmp185__length1 = commands_length1;
	{
		gchar** command_collection = NULL;
		gint command_collection_length1 = 0;
		gint _command_collection_size_ = 0;
		gint command_it = 0;
		command_collection = _tmp185_;
		command_collection_length1 = _tmp185__length1;
		for (command_it = 0; command_it < _tmp185__length1; command_it = command_it + 1) {
			gchar* _tmp186_;
			gchar* command = NULL;
			_tmp186_ = g_strdup (command_collection[command_it]);
			command = _tmp186_;
			{
				GtkTreeIter iter = {0};
				GtkListStore* _tmp187_;
				GtkTreeIter _tmp188_ = {0};
				GtkListStore* _tmp189_;
				GtkTreeIter _tmp190_;
				const gchar* _tmp191_;
				const gchar* _tmp192_;
				gchar* _tmp193_ = NULL;
				gchar* _tmp194_;
				_tmp187_ = model;
				gtk_list_store_append (_tmp187_, &_tmp188_);
				iter = _tmp188_;
				_tmp189_ = model;
				_tmp190_ = iter;
				_tmp191_ = command;
				_tmp192_ = command;
				_tmp193_ = kkc_keymap_get_command_label (_tmp192_);
				_tmp194_ = _tmp193_;
				gtk_list_store_set (_tmp189_, &_tmp190_, 0, _tmp191_, 1, _tmp194_, -1);
				_g_free0 (_tmp194_);
				_g_free0 (command);
			}
		}
	}
	_tmp195_ = self->priv->shortcut_command_combobox;
	gtk_combo_box_set_active (_tmp195_, 0);
	_tmp196_ = (GtkCellRendererText*) gtk_cell_renderer_text_new ();
	g_object_ref_sink (_tmp196_);
	_g_object_unref0 (renderer);
	renderer = (GtkCellRenderer*) _tmp196_;
	_tmp197_ = self->priv->shortcut_command_combobox;
	_tmp198_ = renderer;
	gtk_cell_layout_pack_start ((GtkCellLayout*) _tmp197_, _tmp198_, FALSE);
	_tmp199_ = self->priv->shortcut_command_combobox;
	_tmp200_ = renderer;
	gtk_cell_layout_set_attributes ((GtkCellLayout*) _tmp199_, _tmp200_, "text", 1, NULL);
	_tmp201_ = self->priv->add_shortcut_toolbutton;
	g_signal_connect_object (_tmp201_, "clicked", (GCallback) _setup_add_shortcut_gtk_tool_button_clicked, self, 0);
	_tmp202_ = self->priv->remove_shortcut_toolbutton;
	g_signal_connect_object (_tmp202_, "clicked", (GCallback) _setup_remove_shortcut_gtk_tool_button_clicked, self, 0);
	_tmp203_ = gtk_list_store_new (2, G_TYPE_STRING, G_TYPE_STRING);
	_g_object_unref0 (model);
	model = _tmp203_;
	_tmp204_ = model;
	gtk_tree_sortable_set_sort_column_id ((GtkTreeSortable*) _tmp204_, 1, GTK_SORT_ASCENDING);
	_tmp205_ = self->priv->typing_rule_combobox;
	_tmp206_ = model;
	gtk_combo_box_set_model (_tmp205_, (GtkTreeModel*) _tmp206_);
	_tmp208_ = kkc_rule_list (&_tmp207_);
	rules = _tmp208_;
	rules_length1 = _tmp207_;
	_rules_size_ = rules_length1;
	_tmp209_ = rules;
	_tmp209__length1 = rules_length1;
	{
		KkcRuleMetadata** rule_collection = NULL;
		gint rule_collection_length1 = 0;
		gint _rule_collection_size_ = 0;
		gint rule_it = 0;
		rule_collection = _tmp209_;
		rule_collection_length1 = _tmp209__length1;
		for (rule_it = 0; rule_it < _tmp209__length1; rule_it = rule_it + 1) {
			KkcRuleMetadata* _tmp210_;
			KkcRuleMetadata* rule = NULL;
			_tmp210_ = _g_object_ref0 (rule_collection[rule_it]);
			rule = _tmp210_;
			{
				KkcRuleMetadata* _tmp211_;
				gint _tmp212_;
				gint _tmp213_;
				_tmp211_ = rule;
				_tmp212_ = kkc_rule_metadata_get_priority (_tmp211_);
				_tmp213_ = _tmp212_;
				if (_tmp213_ > 70) {
					GtkTreeIter iter = {0};
					GtkListStore* _tmp214_;
					GtkTreeIter _tmp215_ = {0};
					GtkListStore* _tmp216_;
					GtkTreeIter _tmp217_;
					KkcRuleMetadata* _tmp218_;
					const gchar* _tmp219_;
					const gchar* _tmp220_;
					KkcRuleMetadata* _tmp221_;
					const gchar* _tmp222_;
					const gchar* _tmp223_;
					_tmp214_ = model;
					gtk_list_store_append (_tmp214_, &_tmp215_);
					iter = _tmp215_;
					_tmp216_ = model;
					_tmp217_ = iter;
					_tmp218_ = rule;
					_tmp219_ = kkc_metadata_file_get_name ((KkcMetadataFile*) _tmp218_);
					_tmp220_ = _tmp219_;
					_tmp221_ = rule;
					_tmp222_ = kkc_metadata_file_get_label ((KkcMetadataFile*) _tmp221_);
					_tmp223_ = _tmp222_;
					gtk_list_store_set (_tmp216_, &_tmp217_, 0, _tmp220_, 1, _tmp223_, -1);
				}
				_g_object_unref0 (rule);
			}
		}
	}
	_tmp224_ = (GtkCellRendererText*) gtk_cell_renderer_text_new ();
	g_object_ref_sink (_tmp224_);
	_g_object_unref0 (renderer);
	renderer = (GtkCellRenderer*) _tmp224_;
	_tmp225_ = self->priv->typing_rule_combobox;
	_tmp226_ = renderer;
	gtk_cell_layout_pack_start ((GtkCellLayout*) _tmp225_, _tmp226_, FALSE);
	_tmp227_ = self->priv->typing_rule_combobox;
	_tmp228_ = renderer;
	gtk_cell_layout_set_attributes ((GtkCellLayout*) _tmp227_, _tmp228_, "text", 1, NULL);
	_tmp229_ = (GtkCellRendererText*) gtk_cell_renderer_text_new ();
	g_object_ref_sink (_tmp229_);
	_g_object_unref0 (renderer);
	renderer = (GtkCellRenderer*) _tmp229_;
	_tmp230_ = self->priv->keymap_combobox;
	_tmp231_ = renderer;
	gtk_cell_layout_pack_start ((GtkCellLayout*) _tmp230_, _tmp231_, FALSE);
	_tmp232_ = self->priv->keymap_combobox;
	_tmp233_ = renderer;
	gtk_cell_layout_set_attributes ((GtkCellLayout*) _tmp232_, _tmp233_, "text", 1, NULL);
	_tmp234_ = self->priv->use_custom_keymap_checkbutton;
	g_signal_connect_object ((GtkToggleButton*) _tmp234_, "toggled", (GCallback) ___lambda4__gtk_toggle_button_toggled, self, 0);
	setup_load (self);
	_tmp235_ = add_dict_toolbutton;
	g_signal_connect_object (_tmp235_, "clicked", (GCallback) _setup_add_dict_gtk_tool_button_clicked, self, 0);
	_tmp236_ = _data1_->remove_dict_toolbutton;
	g_signal_connect_object (_tmp236_, "clicked", (GCallback) _setup_remove_dict_gtk_tool_button_clicked, self, 0);
	_tmp237_ = _data1_->up_dict_toolbutton;
	g_signal_connect_object (_tmp237_, "clicked", (GCallback) _setup_up_dict_gtk_tool_button_clicked, self, 0);
	_tmp238_ = _data1_->down_dict_toolbutton;
	g_signal_connect_object (_tmp238_, "clicked", (GCallback) _setup_down_dict_gtk_tool_button_clicked, self, 0);
	_tmp239_ = self->priv->dictionaries_treeview;
	_tmp240_ = gtk_tree_view_get_selection (_tmp239_);
	_tmp241_ = _g_object_ref0 (_tmp240_);
	_data1_->dictionaries_selection = _tmp241_;
	g_signal_connect_data (_data1_->dictionaries_selection, "changed", (GCallback) ___lambda9__gtk_tree_selection_changed, block1_data_ref (_data1_), (GClosureNotify) block1_data_unref, 0);
	rules = (_vala_array_free (rules, rules_length1, (GDestroyNotify) g_object_unref), NULL);
	commands = (_vala_array_free (commands, commands_length1, (GDestroyNotify) g_free), NULL);
	_g_object_unref0 (accel_renderer);
	_g_object_unref0 (column);
	_g_object_unref0 (renderer);
	_g_object_unref0 (model);
	_g_object_unref0 (add_dict_toolbutton);
	_g_object_unref0 (object);
	_g_object_unref0 (builder);
	block1_data_unref (_data1_);
	_data1_ = NULL;
	return self;
}


Setup* setup_new (Preferences* preferences) {
	return setup_construct (TYPE_SETUP, preferences);
}


static void setup_accel_edited (Setup* self, const gchar* path_string, guint keyval, GdkModifierType modifiers, guint keycode) {
	GtkTreeIter iter = {0};
	GtkTreeView* _tmp0_;
	GtkTreeModel* _tmp1_ = NULL;
	GtkListStore* _tmp2_;
	GtkListStore* model;
	GtkListStore* _tmp3_;
	const gchar* _tmp4_;
	GtkTreeIter _tmp5_ = {0};
	gboolean _tmp6_ = FALSE;
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (path_string != NULL);
	_tmp0_ = self->priv->shortcut_treeview;
	_tmp1_ = gtk_tree_view_get_model (_tmp0_);
	_tmp2_ = _g_object_ref0 (G_TYPE_CHECK_INSTANCE_CAST (_tmp1_, GTK_TYPE_LIST_STORE, GtkListStore));
	model = _tmp2_;
	_tmp3_ = model;
	_tmp4_ = path_string;
	_tmp6_ = gtk_tree_model_get_iter_from_string ((GtkTreeModel*) _tmp3_, &_tmp5_, _tmp4_);
	iter = _tmp5_;
	if (_tmp6_) {
		guint _tmp7_;
		guint _tmp8_;
		GdkModifierType _tmp9_;
		KkcKeyEvent* _tmp10_;
		KkcKeyEvent* new_event;
		KkcUserRule* _tmp11_;
		KkcInputMode _tmp12_;
		KkcKeymap* _tmp13_ = NULL;
		KkcKeymap* keymap;
		KkcKeymap* _tmp14_;
		KkcKeyEvent* _tmp15_;
		gchar* _tmp16_ = NULL;
		gchar* old_command;
		const gchar* _tmp17_;
		_tmp7_ = keyval;
		_tmp8_ = keycode;
		_tmp9_ = modifiers;
		_tmp10_ = kkc_key_event_new_from_x_event (_tmp7_, _tmp8_, (KkcModifierType) _tmp9_);
		new_event = _tmp10_;
		_tmp11_ = self->priv->shortcut_rule;
		_tmp12_ = self->priv->shortcut_input_mode;
		_tmp13_ = kkc_rule_get_keymap ((KkcRule*) _tmp11_, _tmp12_);
		keymap = _tmp13_;
		_tmp14_ = keymap;
		_tmp15_ = new_event;
		_tmp16_ = kkc_keymap_lookup_key (_tmp14_, _tmp15_);
		old_command = _tmp16_;
		_tmp17_ = old_command;
		if (_tmp17_ != NULL) {
			gchar* new_command = NULL;
			GtkListStore* _tmp18_;
			GtkTreeIter _tmp19_;
			const gchar* _tmp20_;
			const gchar* _tmp21_;
			_tmp18_ = model;
			_tmp19_ = iter;
			gtk_tree_model_get ((GtkTreeModel*) _tmp18_, &_tmp19_, 0, &new_command, -1, -1);
			_tmp20_ = old_command;
			_tmp21_ = new_command;
			if (g_strcmp0 (_tmp20_, _tmp21_) != 0) {
				GtkDialog* _tmp22_;
				const gchar* _tmp23_ = NULL;
				KkcKeyEvent* _tmp24_;
				gchar* _tmp25_ = NULL;
				gchar* _tmp26_;
				const gchar* _tmp27_;
				GtkMessageDialog* _tmp28_;
				GtkMessageDialog* _tmp29_;
				GtkMessageDialog* error_dialog;
				GtkMessageDialog* _tmp30_;
				GtkMessageDialog* _tmp31_;
				_tmp22_ = self->priv->dialog;
				_tmp23_ = _ ("Shortcut '%s' is already assigned to '%s'");
				_tmp24_ = new_event;
				_tmp25_ = kkc_key_event_to_string (_tmp24_);
				_tmp26_ = _tmp25_;
				_tmp27_ = old_command;
				_tmp28_ = (GtkMessageDialog*) gtk_message_dialog_new ((GtkWindow*) _tmp22_, GTK_DIALOG_MODAL, GTK_MESSAGE_ERROR, GTK_BUTTONS_CLOSE, _tmp23_, _tmp26_, _tmp27_);
				g_object_ref_sink (_tmp28_);
				_tmp29_ = _tmp28_;
				_g_free0 (_tmp26_);
				error_dialog = _tmp29_;
				_tmp30_ = error_dialog;
				gtk_dialog_run ((GtkDialog*) _tmp30_);
				_tmp31_ = error_dialog;
				gtk_widget_destroy ((GtkWidget*) _tmp31_);
				_g_object_unref0 (error_dialog);
			}
			_g_free0 (new_command);
		} else {
			gchar* new_command = NULL;
			KkcKeyEvent* old_event = NULL;
			GtkListStore* _tmp32_;
			GtkTreeIter _tmp33_;
			KkcKeyEvent* _tmp34_;
			KkcKeymap* _tmp37_;
			KkcKeyEvent* _tmp38_;
			const gchar* _tmp39_;
			GtkListStore* _tmp44_;
			GtkTreeIter _tmp45_;
			KkcKeyEvent* _tmp46_;
			GtkComboBox* _tmp47_;
			_tmp32_ = model;
			_tmp33_ = iter;
			gtk_tree_model_get ((GtkTreeModel*) _tmp32_, &_tmp33_, 0, &new_command, 1, &old_event, -1, -1);
			_tmp34_ = old_event;
			if (_tmp34_ != NULL) {
				KkcKeymap* _tmp35_;
				KkcKeyEvent* _tmp36_;
				_tmp35_ = keymap;
				_tmp36_ = old_event;
				kkc_keymap_set (_tmp35_, _tmp36_, NULL);
			}
			_tmp37_ = keymap;
			_tmp38_ = new_event;
			_tmp39_ = new_command;
			kkc_keymap_set (_tmp37_, _tmp38_, _tmp39_);
			{
				KkcUserRule* _tmp40_;
				KkcInputMode _tmp41_;
				_tmp40_ = self->priv->shortcut_rule;
				_tmp41_ = self->priv->shortcut_input_mode;
				kkc_user_rule_write (_tmp40_, _tmp41_, &_inner_error_);
				if (_inner_error_ != NULL) {
					goto __catch1_g_error;
				}
			}
			goto __finally1;
			__catch1_g_error:
			{
				GError* e = NULL;
				GError* _tmp42_;
				const gchar* _tmp43_;
				e = _inner_error_;
				_inner_error_ = NULL;
				_tmp42_ = e;
				_tmp43_ = _tmp42_->message;
				g_warning ("setup.vala:371: can't write shortcut: %s", _tmp43_);
				_g_error_free0 (e);
			}
			__finally1:
			if (_inner_error_ != NULL) {
				_g_free0 (new_command);
				_g_free0 (old_command);
				_g_object_unref0 (keymap);
				_g_object_unref0 (new_event);
				_g_object_unref0 (model);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return;
			}
			_tmp44_ = model;
			_tmp45_ = iter;
			_tmp46_ = new_event;
			gtk_list_store_set (_tmp44_, &_tmp45_, 1, _tmp46_, -1, -1);
			_tmp47_ = self->priv->typing_rule_combobox;
			g_signal_emit_by_name (_tmp47_, "changed");
			_g_free0 (new_command);
		}
		_g_free0 (old_command);
		_g_object_unref0 (keymap);
		_g_object_unref0 (new_event);
	}
	_g_object_unref0 (model);
}


static void setup_accel_cleared (Setup* self, const gchar* path_string) {
	GtkTreeIter iter = {0};
	GtkTreeView* _tmp0_;
	GtkTreeModel* _tmp1_ = NULL;
	GtkListStore* _tmp2_;
	GtkListStore* model;
	GtkListStore* _tmp3_;
	const gchar* _tmp4_;
	GtkTreeIter _tmp5_ = {0};
	gboolean _tmp6_ = FALSE;
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (path_string != NULL);
	_tmp0_ = self->priv->shortcut_treeview;
	_tmp1_ = gtk_tree_view_get_model (_tmp0_);
	_tmp2_ = _g_object_ref0 (G_TYPE_CHECK_INSTANCE_CAST (_tmp1_, GTK_TYPE_LIST_STORE, GtkListStore));
	model = _tmp2_;
	_tmp3_ = model;
	_tmp4_ = path_string;
	_tmp6_ = gtk_tree_model_get_iter_from_string ((GtkTreeModel*) _tmp3_, &_tmp5_, _tmp4_);
	iter = _tmp5_;
	if (_tmp6_) {
		KkcKeyEvent* old_event = NULL;
		GtkListStore* _tmp7_;
		GtkTreeIter _tmp8_;
		KkcUserRule* _tmp9_;
		KkcInputMode _tmp10_;
		KkcKeymap* _tmp11_ = NULL;
		KkcKeymap* keymap;
		KkcKeyEvent* _tmp12_;
		GtkListStore* _tmp19_;
		GtkTreeIter _tmp20_;
		_tmp7_ = model;
		_tmp8_ = iter;
		gtk_tree_model_get ((GtkTreeModel*) _tmp7_, &_tmp8_, 1, &old_event, -1, -1);
		_tmp9_ = self->priv->shortcut_rule;
		_tmp10_ = self->priv->shortcut_input_mode;
		_tmp11_ = kkc_rule_get_keymap ((KkcRule*) _tmp9_, _tmp10_);
		keymap = _tmp11_;
		_tmp12_ = old_event;
		if (_tmp12_ != NULL) {
			KkcKeymap* _tmp13_;
			KkcKeyEvent* _tmp14_;
			_tmp13_ = keymap;
			_tmp14_ = old_event;
			kkc_keymap_set (_tmp13_, _tmp14_, NULL);
		}
		{
			KkcUserRule* _tmp15_;
			KkcInputMode _tmp16_;
			_tmp15_ = self->priv->shortcut_rule;
			_tmp16_ = self->priv->shortcut_input_mode;
			kkc_user_rule_write (_tmp15_, _tmp16_, &_inner_error_);
			if (_inner_error_ != NULL) {
				goto __catch2_g_error;
			}
		}
		goto __finally2;
		__catch2_g_error:
		{
			GError* e = NULL;
			GError* _tmp17_;
			const gchar* _tmp18_;
			e = _inner_error_;
			_inner_error_ = NULL;
			_tmp17_ = e;
			_tmp18_ = _tmp17_->message;
			g_warning ("setup.vala:393: can't write shortcut: %s", _tmp18_);
			_g_error_free0 (e);
		}
		__finally2:
		if (_inner_error_ != NULL) {
			_g_object_unref0 (keymap);
			_g_object_unref0 (model);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return;
		}
		_tmp19_ = model;
		_tmp20_ = iter;
		gtk_list_store_remove (_tmp19_, &_tmp20_);
		_g_object_unref0 (keymap);
	}
	_g_object_unref0 (model);
}


static void setup_add_shortcut (Setup* self) {
	GtkDialog* _tmp0_;
	gint _tmp1_ = 0;
	GtkDialog* _tmp12_;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->shortcut_dialog;
	_tmp1_ = gtk_dialog_run (_tmp0_);
	if (_tmp1_ == ((gint) GTK_RESPONSE_OK)) {
		GtkComboBox* _tmp2_;
		gchar* _tmp3_ = NULL;
		gchar* command;
		GtkTreeIter iter = {0};
		GtkTreeView* _tmp4_;
		GtkTreeModel* _tmp5_ = NULL;
		GtkListStore* _tmp6_;
		GtkListStore* model;
		GtkListStore* _tmp7_;
		GtkTreeIter _tmp8_ = {0};
		GtkListStore* _tmp9_;
		GtkTreeIter _tmp10_;
		const gchar* _tmp11_;
		_tmp2_ = self->priv->shortcut_command_combobox;
		_tmp3_ = setup_combobox_get_active_string (self, _tmp2_, 0);
		command = _tmp3_;
		_tmp4_ = self->priv->shortcut_treeview;
		_tmp5_ = gtk_tree_view_get_model (_tmp4_);
		_tmp6_ = _g_object_ref0 (G_TYPE_CHECK_INSTANCE_CAST (_tmp5_, GTK_TYPE_LIST_STORE, GtkListStore));
		model = _tmp6_;
		_tmp7_ = model;
		gtk_list_store_append (_tmp7_, &_tmp8_);
		iter = _tmp8_;
		_tmp9_ = model;
		_tmp10_ = iter;
		_tmp11_ = command;
		gtk_list_store_set (_tmp9_, &_tmp10_, 0, _tmp11_, 1, NULL, -1, -1);
		_g_object_unref0 (model);
		_g_free0 (command);
	}
	_tmp12_ = self->priv->shortcut_dialog;
	gtk_widget_hide ((GtkWidget*) _tmp12_);
}


static gpointer _gtk_tree_path_copy0 (gpointer self) {
	return self ? gtk_tree_path_copy (self) : NULL;
}


static gboolean _vala_uint_array_contains (guint* stack, int stack_length, guint needle) {
	int i;
	for (i = 0; i < stack_length; i++) {
		if (needle == stack[i]) {
			return TRUE;
		}
	}
	return FALSE;
}


static void _gtk_tree_path_free0_ (gpointer var) {
	(var == NULL) ? NULL : (var = (gtk_tree_path_free (var), NULL));
}


static void _g_list_free__gtk_tree_path_free0_ (GList* self) {
	g_list_foreach (self, (GFunc) _gtk_tree_path_free0_, NULL);
	g_list_free (self);
}


static void setup_remove_shortcut (Setup* self) {
	GtkTreeView* _tmp0_;
	GtkTreeSelection* _tmp1_ = NULL;
	GtkTreeSelection* _tmp2_;
	GtkTreeSelection* selection;
	GtkTreeModel* model = NULL;
	GtkTreeSelection* _tmp3_;
	GtkTreeModel* _tmp4_ = NULL;
	GList* _tmp5_ = NULL;
	GtkTreeModel* _tmp6_;
	GList* rows;
	KkcUserRule* _tmp7_;
	KkcInputMode _tmp8_;
	KkcKeymap* _tmp9_ = NULL;
	KkcKeymap* keymap;
	GList* _tmp10_;
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->shortcut_treeview;
	_tmp1_ = gtk_tree_view_get_selection (_tmp0_);
	_tmp2_ = _g_object_ref0 (_tmp1_);
	selection = _tmp2_;
	_tmp3_ = selection;
	_tmp5_ = gtk_tree_selection_get_selected_rows (_tmp3_, &_tmp4_);
	_g_object_unref0 (model);
	_tmp6_ = _g_object_ref0 (_tmp4_);
	model = _tmp6_;
	rows = _tmp5_;
	_tmp7_ = self->priv->shortcut_rule;
	_tmp8_ = self->priv->shortcut_input_mode;
	_tmp9_ = kkc_rule_get_keymap ((KkcRule*) _tmp7_, _tmp8_);
	keymap = _tmp9_;
	_tmp10_ = rows;
	{
		GList* row_collection = NULL;
		GList* row_it = NULL;
		row_collection = _tmp10_;
		for (row_it = row_collection; row_it != NULL; row_it = row_it->next) {
			GtkTreePath* _tmp11_;
			GtkTreePath* row = NULL;
			_tmp11_ = _gtk_tree_path_copy0 ((GtkTreePath*) row_it->data);
			row = _tmp11_;
			{
				GtkTreeIter iter = {0};
				GtkTreeModel* _tmp12_;
				GtkTreePath* _tmp13_;
				GtkTreeIter _tmp14_ = {0};
				gboolean _tmp15_ = FALSE;
				_tmp12_ = model;
				_tmp13_ = row;
				_tmp15_ = gtk_tree_model_get_iter (_tmp12_, &_tmp14_, _tmp13_);
				iter = _tmp14_;
				if (_tmp15_) {
					KkcKeyEvent* old_event = NULL;
					GtkTreeModel* _tmp16_;
					GtkTreeIter _tmp17_;
					gboolean _tmp18_ = FALSE;
					KkcKeyEvent* _tmp19_;
					KkcModifierType _tmp20_;
					KkcModifierType _tmp21_;
					gboolean _tmp25_;
					KkcKeymap* _tmp26_;
					KkcKeyEvent* _tmp27_;
					GtkTreeModel* _tmp28_;
					GtkTreeIter _tmp29_;
					_tmp16_ = model;
					_tmp17_ = iter;
					gtk_tree_model_get (_tmp16_, &_tmp17_, 1, &old_event, -1, -1);
					_tmp19_ = old_event;
					_tmp20_ = kkc_key_event_get_modifiers (_tmp19_);
					_tmp21_ = _tmp20_;
					if (_tmp21_ == 0) {
						KkcKeyEvent* _tmp22_;
						guint _tmp23_;
						guint _tmp24_;
						_tmp22_ = old_event;
						_tmp23_ = kkc_key_event_get_keyval (_tmp22_);
						_tmp24_ = _tmp23_;
						_tmp18_ = _vala_uint_array_contains (SETUP_IGNORED_KEYVALS, G_N_ELEMENTS (SETUP_IGNORED_KEYVALS), _tmp24_);
					} else {
						_tmp18_ = FALSE;
					}
					_tmp25_ = _tmp18_;
					if (_tmp25_) {
						_gtk_tree_path_free0 (row);
						continue;
					}
					_tmp26_ = keymap;
					_tmp27_ = old_event;
					kkc_keymap_set (_tmp26_, _tmp27_, NULL);
					_tmp28_ = model;
					_tmp29_ = iter;
					gtk_list_store_remove (G_TYPE_CHECK_INSTANCE_CAST (_tmp28_, GTK_TYPE_LIST_STORE, GtkListStore), &_tmp29_);
				}
				_gtk_tree_path_free0 (row);
			}
		}
	}
	{
		KkcUserRule* _tmp30_;
		KkcInputMode _tmp31_;
		_tmp30_ = self->priv->shortcut_rule;
		_tmp31_ = self->priv->shortcut_input_mode;
		kkc_user_rule_write (_tmp30_, _tmp31_, &_inner_error_);
		if (_inner_error_ != NULL) {
			goto __catch3_g_error;
		}
	}
	goto __finally3;
	__catch3_g_error:
	{
		GError* e = NULL;
		GError* _tmp32_;
		const gchar* _tmp33_;
		e = _inner_error_;
		_inner_error_ = NULL;
		_tmp32_ = e;
		_tmp33_ = _tmp32_->message;
		g_warning ("setup.vala:432: can't write shortcut: %s", _tmp33_);
		_g_error_free0 (e);
	}
	__finally3:
	if (_inner_error_ != NULL) {
		_g_object_unref0 (keymap);
		__g_list_free__gtk_tree_path_free0_0 (rows);
		_g_object_unref0 (model);
		_g_object_unref0 (selection);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
	_g_object_unref0 (keymap);
	__g_list_free__gtk_tree_path_free0_0 (rows);
	_g_object_unref0 (model);
	_g_object_unref0 (selection);
}


static void setup_populate_dictionaries_treeview (Setup* self) {
	Preferences* _tmp0_;
	GVariant* _tmp1_ = NULL;
	GVariant* variant;
	GVariant* _tmp2_;
	GVariant* _tmp3_;
	size_t _tmp4_;
	gchar** _tmp5_ = NULL;
	gchar** strv;
	gint strv_length1;
	gint _strv_size_;
	GtkTreeView* _tmp6_;
	GtkTreeModel* _tmp7_ = NULL;
	GtkListStore* _tmp8_;
	GtkListStore* model;
	gchar** _tmp9_;
	gint _tmp9__length1;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->preferences;
	_tmp1_ = preferences_get (_tmp0_, "system_dictionaries");
	variant = _tmp1_;
	_tmp2_ = variant;
	_vala_assert (_tmp2_ != NULL, "variant != null");
	_tmp3_ = variant;
	_tmp5_ = g_variant_dup_strv (_tmp3_, &_tmp4_);
	strv = _tmp5_;
	strv_length1 = _tmp4_;
	_strv_size_ = strv_length1;
	_tmp6_ = self->priv->dictionaries_treeview;
	_tmp7_ = gtk_tree_view_get_model (_tmp6_);
	_tmp8_ = _g_object_ref0 (G_TYPE_CHECK_INSTANCE_CAST (_tmp7_, GTK_TYPE_LIST_STORE, GtkListStore));
	model = _tmp8_;
	_tmp9_ = strv;
	_tmp9__length1 = strv_length1;
	{
		gchar** id_collection = NULL;
		gint id_collection_length1 = 0;
		gint _id_collection_size_ = 0;
		gint id_it = 0;
		id_collection = _tmp9_;
		id_collection_length1 = _tmp9__length1;
		for (id_it = 0; id_it < _tmp9__length1; id_it = id_it + 1) {
			gchar* _tmp10_;
			gchar* id = NULL;
			_tmp10_ = g_strdup (id_collection[id_it]);
			id = _tmp10_;
			{
				Preferences* _tmp11_;
				const gchar* _tmp12_;
				DictionaryMetadata* _tmp13_ = NULL;
				DictionaryMetadata* metadata;
				DictionaryMetadata* _tmp14_;
				_tmp11_ = self->priv->preferences;
				_tmp12_ = id;
				_tmp13_ = preferences_get_dictionary_metadata (_tmp11_, _tmp12_);
				metadata = _tmp13_;
				_tmp14_ = metadata;
				if (_tmp14_ != NULL) {
					GtkTreeIter iter = {0};
					GtkListStore* _tmp15_;
					GtkTreeIter _tmp16_ = {0};
					GtkListStore* _tmp17_;
					GtkTreeIter _tmp18_;
					DictionaryMetadata* _tmp19_;
					DictionaryMetadata* _tmp20_;
					const gchar* _tmp21_;
					const gchar* _tmp22_;
					const gchar* _tmp23_ = NULL;
					_tmp15_ = model;
					gtk_list_store_append (_tmp15_, &_tmp16_);
					iter = _tmp16_;
					_tmp17_ = model;
					_tmp18_ = iter;
					_tmp19_ = metadata;
					_tmp20_ = metadata;
					_tmp21_ = dictionary_metadata_get_description (_tmp20_);
					_tmp22_ = _tmp21_;
					_tmp23_ = g_dgettext (NULL, _tmp22_);
					gtk_list_store_set (_tmp17_, &_tmp18_, 0, _tmp19_, 1, _tmp23_, -1);
				}
				_g_object_unref0 (metadata);
				_g_free0 (id);
			}
		}
	}
	_g_object_unref0 (model);
	strv = (_vala_array_free (strv, strv_length1, (GDestroyNotify) g_free), NULL);
	_g_variant_unref0 (variant);
}


static void setup_populate_available_dictionaries_treeview (Setup* self) {
	Preferences* _tmp0_;
	GVariant* _tmp1_ = NULL;
	GVariant* variant;
	GVariant* _tmp2_;
	GVariant* _tmp3_;
	size_t _tmp4_;
	gchar** _tmp5_ = NULL;
	gchar** strv;
	gint strv_length1;
	gint _strv_size_;
	GeeHashSet* _tmp6_;
	GeeSet* enabled;
	gchar** _tmp7_;
	gint _tmp7__length1;
	GtkTreeView* _tmp11_;
	GtkTreeModel* _tmp12_ = NULL;
	GtkListStore* _tmp13_;
	GtkListStore* model;
	GtkListStore* _tmp14_;
	Preferences* _tmp15_;
	gint _tmp16_ = 0;
	DictionaryMetadata** _tmp17_ = NULL;
	DictionaryMetadata** available_dictionaries;
	gint available_dictionaries_length1;
	gint _available_dictionaries_size_;
	DictionaryMetadata** _tmp18_;
	gint _tmp18__length1;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->preferences;
	_tmp1_ = preferences_get (_tmp0_, "system_dictionaries");
	variant = _tmp1_;
	_tmp2_ = variant;
	_vala_assert (_tmp2_ != NULL, "variant != null");
	_tmp3_ = variant;
	_tmp5_ = g_variant_dup_strv (_tmp3_, &_tmp4_);
	strv = _tmp5_;
	strv_length1 = _tmp4_;
	_strv_size_ = strv_length1;
	_tmp6_ = gee_hash_set_new (G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, g_free, NULL, NULL);
	enabled = (GeeSet*) _tmp6_;
	_tmp7_ = strv;
	_tmp7__length1 = strv_length1;
	{
		gchar** str_collection = NULL;
		gint str_collection_length1 = 0;
		gint _str_collection_size_ = 0;
		gint str_it = 0;
		str_collection = _tmp7_;
		str_collection_length1 = _tmp7__length1;
		for (str_it = 0; str_it < _tmp7__length1; str_it = str_it + 1) {
			gchar* _tmp8_;
			gchar* str = NULL;
			_tmp8_ = g_strdup (str_collection[str_it]);
			str = _tmp8_;
			{
				GeeSet* _tmp9_;
				const gchar* _tmp10_;
				_tmp9_ = enabled;
				_tmp10_ = str;
				gee_collection_add ((GeeCollection*) _tmp9_, _tmp10_);
				_g_free0 (str);
			}
		}
	}
	_tmp11_ = self->priv->available_dictionaries_treeview;
	_tmp12_ = gtk_tree_view_get_model (_tmp11_);
	_tmp13_ = _g_object_ref0 (G_TYPE_CHECK_INSTANCE_CAST (_tmp12_, GTK_TYPE_LIST_STORE, GtkListStore));
	model = _tmp13_;
	_tmp14_ = model;
	gtk_list_store_clear (_tmp14_);
	_tmp15_ = self->priv->preferences;
	_tmp17_ = preferences_list_available_dictionaries (_tmp15_, &_tmp16_);
	available_dictionaries = _tmp17_;
	available_dictionaries_length1 = _tmp16_;
	_available_dictionaries_size_ = available_dictionaries_length1;
	_tmp18_ = available_dictionaries;
	_tmp18__length1 = available_dictionaries_length1;
	{
		DictionaryMetadata** metadata_collection = NULL;
		gint metadata_collection_length1 = 0;
		gint _metadata_collection_size_ = 0;
		gint metadata_it = 0;
		metadata_collection = _tmp18_;
		metadata_collection_length1 = _tmp18__length1;
		for (metadata_it = 0; metadata_it < _tmp18__length1; metadata_it = metadata_it + 1) {
			DictionaryMetadata* _tmp19_;
			DictionaryMetadata* metadata = NULL;
			_tmp19_ = _g_object_ref0 (metadata_collection[metadata_it]);
			metadata = _tmp19_;
			{
				GeeSet* _tmp20_;
				DictionaryMetadata* _tmp21_;
				const gchar* _tmp22_;
				const gchar* _tmp23_;
				gboolean _tmp24_ = FALSE;
				_tmp20_ = enabled;
				_tmp21_ = metadata;
				_tmp22_ = dictionary_metadata_get_id (_tmp21_);
				_tmp23_ = _tmp22_;
				_tmp24_ = gee_collection_contains ((GeeCollection*) _tmp20_, _tmp23_);
				if (!_tmp24_) {
					GtkTreeIter iter = {0};
					GtkListStore* _tmp25_;
					GtkTreeIter _tmp26_ = {0};
					GtkListStore* _tmp27_;
					GtkTreeIter _tmp28_;
					DictionaryMetadata* _tmp29_;
					DictionaryMetadata* _tmp30_;
					const gchar* _tmp31_;
					const gchar* _tmp32_;
					const gchar* _tmp33_ = NULL;
					_tmp25_ = model;
					gtk_list_store_append (_tmp25_, &_tmp26_);
					iter = _tmp26_;
					_tmp27_ = model;
					_tmp28_ = iter;
					_tmp29_ = metadata;
					_tmp30_ = metadata;
					_tmp31_ = dictionary_metadata_get_description (_tmp30_);
					_tmp32_ = _tmp31_;
					_tmp33_ = g_dgettext (NULL, _tmp32_);
					gtk_list_store_set (_tmp27_, &_tmp28_, 0, _tmp29_, 1, _tmp33_, -1);
				}
				_g_object_unref0 (metadata);
			}
		}
	}
	available_dictionaries = (_vala_array_free (available_dictionaries, available_dictionaries_length1, (GDestroyNotify) g_object_unref), NULL);
	_g_object_unref0 (model);
	_g_object_unref0 (enabled);
	strv = (_vala_array_free (strv, strv_length1, (GDestroyNotify) g_free), NULL);
	_g_variant_unref0 (variant);
}


static void _vala_KkcKeymapEntry_array_free (KkcKeymapEntry* array, gint array_length) {
	if (array != NULL) {
		int i;
		for (i = 0; i < array_length; i = i + 1) {
			kkc_keymap_entry_destroy (&array[i]);
		}
	}
	g_free (array);
}


static void setup_populate_shortcut_treeview (Setup* self, KkcInputMode input_mode) {
	Preferences* _tmp0_;
	GVariant* _tmp1_ = NULL;
	GVariant* variant;
	const gchar* _tmp2_ = NULL;
	KkcRuleMetadata* _tmp3_ = NULL;
	KkcRuleMetadata* parent_metadata;
	const gchar* _tmp4_ = NULL;
	gchar* _tmp5_ = NULL;
	gchar* base_dir;
	KkcUserRule* rule = NULL;
	GtkTreeView* _tmp10_;
	GtkTreeModel* _tmp11_ = NULL;
	GtkListStore* _tmp12_;
	GtkListStore* model;
	GtkListStore* _tmp13_;
	KkcInputMode _tmp14_;
	KkcKeymap* _tmp15_ = NULL;
	KkcKeymap* _tmp16_;
	gint _tmp17_ = 0;
	KkcKeymapEntry* _tmp18_ = NULL;
	KkcKeymapEntry* _tmp19_;
	gint _tmp19__length1;
	KkcKeymapEntry* entries;
	gint entries_length1;
	gint _entries_size_;
	KkcKeymapEntry* _tmp20_;
	gint _tmp20__length1;
	KkcInputMode _tmp36_;
	KkcUserRule* _tmp37_;
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->preferences;
	_tmp1_ = preferences_get (_tmp0_, "typing_rule");
	variant = _tmp1_;
	_vala_assert (variant != NULL, "variant != null");
	_tmp2_ = g_variant_get_string (variant, NULL);
	_tmp3_ = kkc_rule_metadata_find (_tmp2_);
	parent_metadata = _tmp3_;
	_vala_assert (parent_metadata != NULL, "parent_metadata != null");
	_tmp4_ = g_get_user_config_dir ();
	_tmp5_ = g_build_filename (_tmp4_, "ibus-kkc", "rules", NULL);
	base_dir = _tmp5_;
	{
		KkcUserRule* _tmp6_;
		KkcUserRule* _tmp7_;
		_tmp6_ = kkc_user_rule_new (parent_metadata, base_dir, "ibus-kkc", &_inner_error_);
		_tmp7_ = _tmp6_;
		if (_inner_error_ != NULL) {
			goto __catch4_g_error;
		}
		_g_object_unref0 (rule);
		rule = _tmp7_;
	}
	goto __finally4;
	__catch4_g_error:
	{
		GError* e = NULL;
		const gchar* _tmp8_ = NULL;
		const gchar* _tmp9_;
		e = _inner_error_;
		_inner_error_ = NULL;
		_tmp8_ = g_variant_get_string (variant, NULL);
		_tmp9_ = e->message;
		g_error ("setup.vala:491: can't load typing rule %s: %s", _tmp8_, _tmp9_);
		_g_error_free0 (e);
	}
	__finally4:
	if (_inner_error_ != NULL) {
		_g_object_unref0 (rule);
		_g_free0 (base_dir);
		_g_object_unref0 (parent_metadata);
		_g_variant_unref0 (variant);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
	_tmp10_ = self->priv->shortcut_treeview;
	_tmp11_ = gtk_tree_view_get_model (_tmp10_);
	_tmp12_ = _g_object_ref0 (G_TYPE_CHECK_INSTANCE_CAST (_tmp11_, GTK_TYPE_LIST_STORE, GtkListStore));
	model = _tmp12_;
	_tmp13_ = model;
	gtk_list_store_clear (_tmp13_);
	_tmp14_ = input_mode;
	_tmp15_ = kkc_rule_get_keymap ((KkcRule*) rule, _tmp14_);
	_tmp16_ = _tmp15_;
	_tmp18_ = kkc_keymap_entries (_tmp16_, &_tmp17_);
	_tmp19_ = _tmp18_;
	_tmp19__length1 = _tmp17_;
	_g_object_unref0 (_tmp16_);
	entries = _tmp19_;
	entries_length1 = _tmp19__length1;
	_entries_size_ = entries_length1;
	_tmp20_ = entries;
	_tmp20__length1 = entries_length1;
	{
		KkcKeymapEntry* entry_collection = NULL;
		gint entry_collection_length1 = 0;
		gint _entry_collection_size_ = 0;
		gint entry_it = 0;
		entry_collection = _tmp20_;
		entry_collection_length1 = _tmp20__length1;
		for (entry_it = 0; entry_it < _tmp20__length1; entry_it = entry_it + 1) {
			KkcKeymapEntry _tmp21_ = {0};
			KkcKeymapEntry entry = {0};
			kkc_keymap_entry_copy (&entry_collection[entry_it], &_tmp21_);
			entry = _tmp21_;
			{
				KkcKeymapEntry _tmp22_;
				const gchar* _tmp23_;
				_tmp22_ = entry;
				_tmp23_ = _tmp22_.command;
				if (_tmp23_ != NULL) {
					GtkTreeIter iter = {0};
					GtkListStore* _tmp24_;
					GtkTreeIter _tmp25_ = {0};
					GtkListStore* _tmp26_;
					GtkTreeIter _tmp27_;
					KkcKeymapEntry _tmp28_;
					const gchar* _tmp29_;
					KkcKeymapEntry _tmp30_;
					KkcKeyEvent* _tmp31_;
					KkcKeymapEntry _tmp32_;
					const gchar* _tmp33_;
					gchar* _tmp34_ = NULL;
					gchar* _tmp35_;
					_tmp24_ = model;
					gtk_list_store_append (_tmp24_, &_tmp25_);
					iter = _tmp25_;
					_tmp26_ = model;
					_tmp27_ = iter;
					_tmp28_ = entry;
					_tmp29_ = _tmp28_.command;
					_tmp30_ = entry;
					_tmp31_ = _tmp30_.key;
					_tmp32_ = entry;
					_tmp33_ = _tmp32_.command;
					_tmp34_ = kkc_keymap_get_command_label (_tmp33_);
					_tmp35_ = _tmp34_;
					gtk_list_store_set (_tmp26_, &_tmp27_, 0, _tmp29_, 1, _tmp31_, 2, _tmp35_, -1);
					_g_free0 (_tmp35_);
				}
				kkc_keymap_entry_destroy (&entry);
			}
		}
	}
	_tmp36_ = input_mode;
	self->priv->shortcut_input_mode = _tmp36_;
	_tmp37_ = _g_object_ref0 (rule);
	_g_object_unref0 (self->priv->shortcut_rule);
	self->priv->shortcut_rule = _tmp37_;
	entries = (_vala_KkcKeymapEntry_array_free (entries, entries_length1), NULL);
	_g_object_unref0 (model);
	_g_object_unref0 (rule);
	_g_free0 (base_dir);
	_g_object_unref0 (parent_metadata);
	_g_variant_unref0 (variant);
}


static gchar* setup_combobox_get_active_string (Setup* self, GtkComboBox* combo, gint column) {
	gchar* result = NULL;
	gchar* text = NULL;
	GtkTreeIter iter = {0};
	GtkComboBox* _tmp0_;
	GtkTreeIter _tmp1_ = {0};
	gboolean _tmp2_ = FALSE;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (combo != NULL, NULL);
	_tmp0_ = combo;
	_tmp2_ = gtk_combo_box_get_active_iter (_tmp0_, &_tmp1_);
	iter = _tmp1_;
	if (_tmp2_) {
		GtkComboBox* _tmp3_;
		GtkTreeModel* _tmp4_ = NULL;
		GtkListStore* _tmp5_;
		GtkListStore* model;
		GtkTreeIter _tmp6_;
		gint _tmp7_;
		_tmp3_ = combo;
		_tmp4_ = gtk_combo_box_get_model (_tmp3_);
		_tmp5_ = _g_object_ref0 (G_TYPE_CHECK_INSTANCE_CAST (_tmp4_, GTK_TYPE_LIST_STORE, GtkListStore));
		model = _tmp5_;
		_tmp6_ = iter;
		_tmp7_ = column;
		gtk_tree_model_get ((GtkTreeModel*) model, &_tmp6_, _tmp7_, &text, -1, -1);
		_g_object_unref0 (model);
	} else {
		g_assert_not_reached ();
	}
	result = text;
	return result;
}


static void setup_add_dict (Setup* self) {
	GtkDialog* _tmp0_;
	gint _tmp1_ = 0;
	GtkDialog* _tmp25_;
	g_return_if_fail (self != NULL);
	setup_populate_available_dictionaries_treeview (self);
	_tmp0_ = self->priv->dict_dialog;
	_tmp1_ = gtk_dialog_run (_tmp0_);
	if (_tmp1_ == ((gint) GTK_RESPONSE_OK)) {
		GtkTreeView* _tmp2_;
		GtkTreeModel* _tmp3_ = NULL;
		GtkListStore* _tmp4_;
		GtkListStore* model;
		GtkTreeView* _tmp5_;
		GtkTreeSelection* _tmp6_ = NULL;
		GtkTreeSelection* _tmp7_;
		GtkTreeSelection* selection;
		GtkTreeModel* available_model = NULL;
		GtkTreeSelection* _tmp8_;
		GtkTreeModel* _tmp9_ = NULL;
		GList* _tmp10_ = NULL;
		GtkTreeModel* _tmp11_;
		GList* rows;
		GList* _tmp12_;
		_tmp2_ = self->priv->dictionaries_treeview;
		_tmp3_ = gtk_tree_view_get_model (_tmp2_);
		_tmp4_ = _g_object_ref0 (G_TYPE_CHECK_INSTANCE_CAST (_tmp3_, GTK_TYPE_LIST_STORE, GtkListStore));
		model = _tmp4_;
		_tmp5_ = self->priv->available_dictionaries_treeview;
		_tmp6_ = gtk_tree_view_get_selection (_tmp5_);
		_tmp7_ = _g_object_ref0 (_tmp6_);
		selection = _tmp7_;
		_tmp8_ = selection;
		_tmp10_ = gtk_tree_selection_get_selected_rows (_tmp8_, &_tmp9_);
		_g_object_unref0 (available_model);
		_tmp11_ = _g_object_ref0 (_tmp9_);
		available_model = _tmp11_;
		rows = _tmp10_;
		_tmp12_ = rows;
		{
			GList* row_collection = NULL;
			GList* row_it = NULL;
			row_collection = _tmp12_;
			for (row_it = row_collection; row_it != NULL; row_it = row_it->next) {
				GtkTreePath* _tmp13_;
				GtkTreePath* row = NULL;
				_tmp13_ = _gtk_tree_path_copy0 ((GtkTreePath*) row_it->data);
				row = _tmp13_;
				{
					GtkTreeIter available_iter = {0};
					GtkTreeModel* _tmp14_;
					GtkTreePath* _tmp15_;
					GtkTreeIter _tmp16_ = {0};
					gboolean _tmp17_ = FALSE;
					_tmp14_ = available_model;
					_tmp15_ = row;
					_tmp17_ = gtk_tree_model_get_iter (_tmp14_, &_tmp16_, _tmp15_);
					available_iter = _tmp16_;
					if (_tmp17_) {
						DictionaryMetadata* metadata = NULL;
						GtkTreeModel* _tmp18_;
						GtkTreeIter _tmp19_;
						GtkTreeIter iter = {0};
						GtkListStore* _tmp20_;
						GtkTreeIter _tmp21_ = {0};
						GtkListStore* _tmp22_;
						GtkTreeIter _tmp23_;
						DictionaryMetadata* _tmp24_;
						_tmp18_ = available_model;
						_tmp19_ = available_iter;
						gtk_tree_model_get (_tmp18_, &_tmp19_, 0, &metadata, -1, -1);
						_tmp20_ = model;
						gtk_list_store_append (_tmp20_, &_tmp21_);
						iter = _tmp21_;
						_tmp22_ = model;
						_tmp23_ = iter;
						_tmp24_ = metadata;
						gtk_list_store_set (_tmp22_, &_tmp23_, 0, _tmp24_, -1);
						_g_object_unref0 (metadata);
					}
					_gtk_tree_path_free0 (row);
				}
			}
		}
		setup_save_dictionaries (self, "system_dictionaries");
		__g_list_free__gtk_tree_path_free0_0 (rows);
		_g_object_unref0 (available_model);
		_g_object_unref0 (selection);
		_g_object_unref0 (model);
	}
	_tmp25_ = self->priv->dict_dialog;
	gtk_widget_hide ((GtkWidget*) _tmp25_);
}


static void setup_remove_dict (Setup* self) {
	GtkTreeView* _tmp0_;
	GtkTreeSelection* _tmp1_ = NULL;
	GtkTreeSelection* _tmp2_;
	GtkTreeSelection* selection;
	GtkTreeModel* model = NULL;
	GtkTreeSelection* _tmp3_;
	GtkTreeModel* _tmp4_ = NULL;
	GList* _tmp5_ = NULL;
	GtkTreeModel* _tmp6_;
	GList* rows;
	GList* _tmp7_;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->dictionaries_treeview;
	_tmp1_ = gtk_tree_view_get_selection (_tmp0_);
	_tmp2_ = _g_object_ref0 (_tmp1_);
	selection = _tmp2_;
	_tmp3_ = selection;
	_tmp5_ = gtk_tree_selection_get_selected_rows (_tmp3_, &_tmp4_);
	_g_object_unref0 (model);
	_tmp6_ = _g_object_ref0 (_tmp4_);
	model = _tmp6_;
	rows = _tmp5_;
	_tmp7_ = rows;
	{
		GList* row_collection = NULL;
		GList* row_it = NULL;
		row_collection = _tmp7_;
		for (row_it = row_collection; row_it != NULL; row_it = row_it->next) {
			GtkTreePath* _tmp8_;
			GtkTreePath* row = NULL;
			_tmp8_ = _gtk_tree_path_copy0 ((GtkTreePath*) row_it->data);
			row = _tmp8_;
			{
				GtkTreeIter iter = {0};
				GtkTreeModel* _tmp9_;
				GtkTreePath* _tmp10_;
				GtkTreeIter _tmp11_ = {0};
				gboolean _tmp12_ = FALSE;
				_tmp9_ = model;
				_tmp10_ = row;
				_tmp12_ = gtk_tree_model_get_iter (_tmp9_, &_tmp11_, _tmp10_);
				iter = _tmp11_;
				if (_tmp12_) {
					GtkTreeModel* _tmp13_;
					GtkTreeIter _tmp14_;
					_tmp13_ = model;
					_tmp14_ = iter;
					gtk_list_store_remove (G_TYPE_CHECK_INSTANCE_CAST (_tmp13_, GTK_TYPE_LIST_STORE, GtkListStore), &_tmp14_);
				}
				_gtk_tree_path_free0 (row);
			}
		}
	}
	setup_save_dictionaries (self, "system_dictionaries");
	__g_list_free__gtk_tree_path_free0_0 (rows);
	_g_object_unref0 (model);
	_g_object_unref0 (selection);
}


static void setup_up_dict (Setup* self) {
	GtkTreeView* _tmp0_;
	GtkTreeSelection* _tmp1_ = NULL;
	GtkTreeSelection* _tmp2_;
	GtkTreeSelection* selection;
	GtkTreeModel* model = NULL;
	GtkTreeIter iter = {0};
	GtkTreeSelection* _tmp3_;
	GtkTreeModel* _tmp4_ = NULL;
	GtkTreeIter _tmp5_ = {0};
	gboolean _tmp6_ = FALSE;
	GtkTreeModel* _tmp7_;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->dictionaries_treeview;
	_tmp1_ = gtk_tree_view_get_selection (_tmp0_);
	_tmp2_ = _g_object_ref0 (_tmp1_);
	selection = _tmp2_;
	_tmp3_ = selection;
	_tmp6_ = gtk_tree_selection_get_selected (_tmp3_, &_tmp4_, &_tmp5_);
	_g_object_unref0 (model);
	_tmp7_ = _g_object_ref0 (_tmp4_);
	model = _tmp7_;
	iter = _tmp5_;
	if (_tmp6_) {
		GtkTreeIter _tmp8_;
		GtkTreeIter prev;
		GtkTreeModel* _tmp9_;
		gboolean _tmp10_ = FALSE;
		_tmp8_ = iter;
		prev = _tmp8_;
		_tmp9_ = model;
		_tmp10_ = gtk_tree_model_iter_previous (_tmp9_, &prev);
		if (_tmp10_) {
			GtkTreeModel* _tmp11_;
			GtkTreeIter _tmp12_;
			GtkTreeIter _tmp13_;
			_tmp11_ = model;
			_tmp12_ = iter;
			_tmp13_ = prev;
			gtk_list_store_swap (G_TYPE_CHECK_INSTANCE_CAST (_tmp11_, GTK_TYPE_LIST_STORE, GtkListStore), &_tmp12_, &_tmp13_);
		}
	}
	setup_save_dictionaries (self, "system_dictionaries");
	_g_object_unref0 (model);
	_g_object_unref0 (selection);
}


static void setup_down_dict (Setup* self) {
	GtkTreeView* _tmp0_;
	GtkTreeSelection* _tmp1_ = NULL;
	GtkTreeSelection* _tmp2_;
	GtkTreeSelection* selection;
	GtkTreeModel* model = NULL;
	GtkTreeIter iter = {0};
	GtkTreeSelection* _tmp3_;
	GtkTreeModel* _tmp4_ = NULL;
	GtkTreeIter _tmp5_ = {0};
	gboolean _tmp6_ = FALSE;
	GtkTreeModel* _tmp7_;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->dictionaries_treeview;
	_tmp1_ = gtk_tree_view_get_selection (_tmp0_);
	_tmp2_ = _g_object_ref0 (_tmp1_);
	selection = _tmp2_;
	_tmp3_ = selection;
	_tmp6_ = gtk_tree_selection_get_selected (_tmp3_, &_tmp4_, &_tmp5_);
	_g_object_unref0 (model);
	_tmp7_ = _g_object_ref0 (_tmp4_);
	model = _tmp7_;
	iter = _tmp5_;
	if (_tmp6_) {
		GtkTreeIter _tmp8_;
		GtkTreeIter next;
		GtkTreeModel* _tmp9_;
		gboolean _tmp10_ = FALSE;
		_tmp8_ = iter;
		next = _tmp8_;
		_tmp9_ = model;
		_tmp10_ = gtk_tree_model_iter_next (_tmp9_, &next);
		if (_tmp10_) {
			GtkTreeModel* _tmp11_;
			GtkTreeIter _tmp12_;
			GtkTreeIter _tmp13_;
			_tmp11_ = model;
			_tmp12_ = iter;
			_tmp13_ = next;
			gtk_list_store_swap (G_TYPE_CHECK_INSTANCE_CAST (_tmp11_, GTK_TYPE_LIST_STORE, GtkListStore), &_tmp12_, &_tmp13_);
		}
	}
	setup_save_dictionaries (self, "system_dictionaries");
	_g_object_unref0 (model);
	_g_object_unref0 (selection);
}


static Block2Data* block2_data_ref (Block2Data* _data2_) {
	g_atomic_int_inc (&_data2_->_ref_count_);
	return _data2_;
}


static void block2_data_unref (void * _userdata_) {
	Block2Data* _data2_;
	_data2_ = (Block2Data*) _userdata_;
	if (g_atomic_int_dec_and_test (&_data2_->_ref_count_)) {
		Setup * self;
		self = _data2_->self;
		_g_free0 (_data2_->name);
		_g_object_unref0 (_data2_->spin);
		_g_object_unref0 (self);
		g_slice_free (Block2Data, _data2_);
	}
}


static GVariant* _variant_new1 (gint value) {
	return g_variant_ref_sink (g_variant_new_int32 (value));
}


static void __lambda8_ (Block2Data* _data2_) {
	Setup * self;
	Preferences* _tmp0_;
	const gchar* _tmp1_;
	GtkSpinButton* _tmp2_;
	gdouble _tmp3_;
	gdouble _tmp4_;
	GVariant* _tmp5_;
	self = _data2_->self;
	_tmp0_ = self->priv->preferences;
	_tmp1_ = _data2_->name;
	_tmp2_ = _data2_->spin;
	_tmp3_ = gtk_spin_button_get_value (_tmp2_);
	_tmp4_ = _tmp3_;
	_tmp5_ = _variant_new1 ((gint) _tmp4_);
	preferences_set (_tmp0_, _tmp1_, _tmp5_);
}


static void ___lambda8__gtk_spin_button_value_changed (GtkSpinButton* _sender, gpointer self) {
	__lambda8_ (self);
}


static void setup_load_spinbutton (Setup* self, const gchar* name, GtkSpinButton* spin) {
	Block2Data* _data2_;
	const gchar* _tmp0_;
	gchar* _tmp1_;
	GtkSpinButton* _tmp2_;
	GtkSpinButton* _tmp3_;
	Preferences* _tmp4_;
	const gchar* _tmp5_;
	GVariant* _tmp6_ = NULL;
	GVariant* variant;
	GtkSpinButton* _tmp7_;
	gint32 _tmp8_ = 0;
	GtkSpinButton* _tmp9_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (name != NULL);
	g_return_if_fail (spin != NULL);
	_data2_ = g_slice_new0 (Block2Data);
	_data2_->_ref_count_ = 1;
	_data2_->self = g_object_ref (self);
	_tmp0_ = name;
	_tmp1_ = g_strdup (_tmp0_);
	_g_free0 (_data2_->name);
	_data2_->name = _tmp1_;
	_tmp2_ = spin;
	_tmp3_ = _g_object_ref0 (_tmp2_);
	_g_object_unref0 (_data2_->spin);
	_data2_->spin = _tmp3_;
	_tmp4_ = self->priv->preferences;
	_tmp5_ = _data2_->name;
	_tmp6_ = preferences_get (_tmp4_, _tmp5_);
	variant = _tmp6_;
	_vala_assert (variant != NULL, "variant != null");
	_tmp7_ = _data2_->spin;
	_tmp8_ = g_variant_get_int32 (variant);
	gtk_spin_button_set_value (_tmp7_, (gdouble) _tmp8_);
	_tmp9_ = _data2_->spin;
	g_signal_connect_data (_tmp9_, "value-changed", (GCallback) ___lambda8__gtk_spin_button_value_changed, block2_data_ref (_data2_), (GClosureNotify) block2_data_unref, 0);
	_g_variant_unref0 (variant);
	block2_data_unref (_data2_);
	_data2_ = NULL;
}


static Block3Data* block3_data_ref (Block3Data* _data3_) {
	g_atomic_int_inc (&_data3_->_ref_count_);
	return _data3_;
}


static void block3_data_unref (void * _userdata_) {
	Block3Data* _data3_;
	_data3_ = (Block3Data*) _userdata_;
	if (g_atomic_int_dec_and_test (&_data3_->_ref_count_)) {
		Setup * self;
		self = _data3_->self;
		_g_free0 (_data3_->name);
		_g_object_unref0 (_data3_->toggle);
		_g_object_unref0 (self);
		g_slice_free (Block3Data, _data3_);
	}
}


static GVariant* _variant_new2 (gboolean value) {
	return g_variant_ref_sink (g_variant_new_boolean (value));
}


static void __lambda7_ (Block3Data* _data3_) {
	Setup * self;
	Preferences* _tmp0_;
	const gchar* _tmp1_;
	GtkToggleButton* _tmp2_;
	gboolean _tmp3_;
	gboolean _tmp4_;
	GVariant* _tmp5_;
	self = _data3_->self;
	_tmp0_ = self->priv->preferences;
	_tmp1_ = _data3_->name;
	_tmp2_ = _data3_->toggle;
	_tmp3_ = gtk_toggle_button_get_active (_tmp2_);
	_tmp4_ = _tmp3_;
	_tmp5_ = _variant_new2 (_tmp4_);
	preferences_set (_tmp0_, _tmp1_, _tmp5_);
}


static void ___lambda7__gtk_toggle_button_toggled (GtkToggleButton* _sender, gpointer self) {
	__lambda7_ (self);
}


static void setup_load_togglebutton (Setup* self, const gchar* name, GtkToggleButton* toggle) {
	Block3Data* _data3_;
	const gchar* _tmp0_;
	gchar* _tmp1_;
	GtkToggleButton* _tmp2_;
	GtkToggleButton* _tmp3_;
	Preferences* _tmp4_;
	const gchar* _tmp5_;
	GVariant* _tmp6_ = NULL;
	GVariant* variant;
	GtkToggleButton* _tmp7_;
	gboolean _tmp8_ = FALSE;
	GtkToggleButton* _tmp9_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (name != NULL);
	g_return_if_fail (toggle != NULL);
	_data3_ = g_slice_new0 (Block3Data);
	_data3_->_ref_count_ = 1;
	_data3_->self = g_object_ref (self);
	_tmp0_ = name;
	_tmp1_ = g_strdup (_tmp0_);
	_g_free0 (_data3_->name);
	_data3_->name = _tmp1_;
	_tmp2_ = toggle;
	_tmp3_ = _g_object_ref0 (_tmp2_);
	_g_object_unref0 (_data3_->toggle);
	_data3_->toggle = _tmp3_;
	_tmp4_ = self->priv->preferences;
	_tmp5_ = _data3_->name;
	_tmp6_ = preferences_get (_tmp4_, _tmp5_);
	variant = _tmp6_;
	_vala_assert (variant != NULL, "variant != null");
	_tmp7_ = _data3_->toggle;
	_tmp8_ = g_variant_get_boolean (variant);
	gtk_toggle_button_set_active (_tmp7_, _tmp8_);
	_tmp9_ = _data3_->toggle;
	g_signal_connect_data (_tmp9_, "toggled", (GCallback) ___lambda7__gtk_toggle_button_toggled, block3_data_ref (_data3_), (GClosureNotify) block3_data_unref, 0);
	_g_variant_unref0 (variant);
	block3_data_unref (_data3_);
	_data3_ = NULL;
}


static Block4Data* block4_data_ref (Block4Data* _data4_) {
	g_atomic_int_inc (&_data4_->_ref_count_);
	return _data4_;
}


static void block4_data_unref (void * _userdata_) {
	Block4Data* _data4_;
	_data4_ = (Block4Data*) _userdata_;
	if (g_atomic_int_dec_and_test (&_data4_->_ref_count_)) {
		Setup * self;
		self = _data4_->self;
		_g_free0 (_data4_->name);
		_g_object_unref0 (_data4_->combo);
		_g_object_unref0 (self);
		g_slice_free (Block4Data, _data4_);
	}
}


static void __lambda6_ (Block4Data* _data4_) {
	Setup * self;
	const gchar* _tmp0_;
	GtkComboBox* _tmp1_;
	gint _tmp2_;
	self = _data4_->self;
	_tmp0_ = _data4_->name;
	_tmp1_ = _data4_->combo;
	_tmp2_ = _data4_->column;
	setup_save_combobox (self, _tmp0_, _tmp1_, _tmp2_);
}


static void ___lambda6__gtk_combo_box_changed (GtkComboBox* _sender, gpointer self) {
	__lambda6_ (self);
}


static void setup_load_combobox (Setup* self, const gchar* name, GtkComboBox* combo, gint column) {
	Block4Data* _data4_;
	const gchar* _tmp0_;
	gchar* _tmp1_;
	GtkComboBox* _tmp2_;
	GtkComboBox* _tmp3_;
	gint _tmp4_;
	Preferences* _tmp5_;
	const gchar* _tmp6_;
	GVariant* _tmp7_ = NULL;
	GVariant* variant;
	GVariant* _tmp8_;
	GtkTreeIter iter = {0};
	GtkComboBox* _tmp9_;
	GtkTreeModel* _tmp10_ = NULL;
	GtkTreeModel* _tmp11_;
	GtkTreeModel* model;
	GtkTreeModel* _tmp12_;
	GtkTreeIter _tmp13_ = {0};
	gboolean _tmp14_ = FALSE;
	GtkComboBox* _tmp28_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (name != NULL);
	g_return_if_fail (combo != NULL);
	_data4_ = g_slice_new0 (Block4Data);
	_data4_->_ref_count_ = 1;
	_data4_->self = g_object_ref (self);
	_tmp0_ = name;
	_tmp1_ = g_strdup (_tmp0_);
	_g_free0 (_data4_->name);
	_data4_->name = _tmp1_;
	_tmp2_ = combo;
	_tmp3_ = _g_object_ref0 (_tmp2_);
	_g_object_unref0 (_data4_->combo);
	_data4_->combo = _tmp3_;
	_tmp4_ = column;
	_data4_->column = _tmp4_;
	_tmp5_ = self->priv->preferences;
	_tmp6_ = _data4_->name;
	_tmp7_ = preferences_get (_tmp5_, _tmp6_);
	variant = _tmp7_;
	_tmp8_ = variant;
	_vala_assert (_tmp8_ != NULL, "variant != null");
	_tmp9_ = _data4_->combo;
	_tmp10_ = gtk_combo_box_get_model (_tmp9_);
	_tmp11_ = _g_object_ref0 (_tmp10_);
	model = _tmp11_;
	_tmp12_ = model;
	_tmp14_ = gtk_tree_model_get_iter_first (_tmp12_, &_tmp13_);
	iter = _tmp13_;
	if (_tmp14_) {
		GVariant* _tmp15_;
		gint32 _tmp16_ = 0;
		gint32 index;
		gint _index = 0;
		_tmp15_ = variant;
		_tmp16_ = g_variant_get_int32 (_tmp15_);
		index = _tmp16_;
		{
			gboolean _tmp17_;
			_tmp17_ = TRUE;
			while (TRUE) {
				gboolean _tmp18_;
				GtkTreeModel* _tmp21_;
				GtkTreeIter _tmp22_;
				gint _tmp23_;
				gint32 _tmp24_;
				gint _tmp25_;
				_tmp18_ = _tmp17_;
				if (!_tmp18_) {
					GtkTreeModel* _tmp19_;
					gboolean _tmp20_ = FALSE;
					_tmp19_ = model;
					_tmp20_ = gtk_tree_model_iter_next (_tmp19_, &iter);
					if (!_tmp20_) {
						break;
					}
				}
				_tmp17_ = FALSE;
				_tmp21_ = model;
				_tmp22_ = iter;
				_tmp23_ = _data4_->column;
				gtk_tree_model_get (_tmp21_, &_tmp22_, _tmp23_, &_index, -1, -1);
				_tmp24_ = index;
				_tmp25_ = _index;
				if (_tmp24_ == ((gint32) _tmp25_)) {
					GtkComboBox* _tmp26_;
					GtkTreeIter _tmp27_;
					_tmp26_ = _data4_->combo;
					_tmp27_ = iter;
					gtk_combo_box_set_active_iter (_tmp26_, &_tmp27_);
					break;
				}
			}
		}
	}
	_tmp28_ = _data4_->combo;
	g_signal_connect_data (_tmp28_, "changed", (GCallback) ___lambda6__gtk_combo_box_changed, block4_data_ref (_data4_), (GClosureNotify) block4_data_unref, 0);
	_g_object_unref0 (model);
	_g_variant_unref0 (variant);
	block4_data_unref (_data4_);
	_data4_ = NULL;
}


static Block5Data* block5_data_ref (Block5Data* _data5_) {
	g_atomic_int_inc (&_data5_->_ref_count_);
	return _data5_;
}


static void block5_data_unref (void * _userdata_) {
	Block5Data* _data5_;
	_data5_ = (Block5Data*) _userdata_;
	if (g_atomic_int_dec_and_test (&_data5_->_ref_count_)) {
		Setup * self;
		self = _data5_->self;
		_g_free0 (_data5_->name);
		_g_object_unref0 (_data5_->combo);
		_g_object_unref0 (self);
		g_slice_free (Block5Data, _data5_);
	}
}


static void __lambda5_ (Block5Data* _data5_) {
	Setup * self;
	const gchar* _tmp0_;
	GtkComboBox* _tmp1_;
	gint _tmp2_;
	self = _data5_->self;
	_tmp0_ = _data5_->name;
	_tmp1_ = _data5_->combo;
	_tmp2_ = _data5_->column;
	setup_save_combobox_string (self, _tmp0_, _tmp1_, _tmp2_);
}


static void ___lambda5__gtk_combo_box_changed (GtkComboBox* _sender, gpointer self) {
	__lambda5_ (self);
}


static void setup_load_combobox_string (Setup* self, const gchar* name, GtkComboBox* combo, gint column) {
	Block5Data* _data5_;
	const gchar* _tmp0_;
	gchar* _tmp1_;
	GtkComboBox* _tmp2_;
	GtkComboBox* _tmp3_;
	gint _tmp4_;
	Preferences* _tmp5_;
	const gchar* _tmp6_;
	GVariant* _tmp7_ = NULL;
	GVariant* variant;
	GVariant* _tmp8_;
	GtkTreeIter iter = {0};
	GtkComboBox* _tmp9_;
	GtkTreeModel* _tmp10_ = NULL;
	GtkTreeModel* _tmp11_;
	GtkTreeModel* model;
	GtkTreeModel* _tmp12_;
	GtkTreeIter _tmp13_ = {0};
	gboolean _tmp14_ = FALSE;
	GtkComboBox* _tmp29_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (name != NULL);
	g_return_if_fail (combo != NULL);
	_data5_ = g_slice_new0 (Block5Data);
	_data5_->_ref_count_ = 1;
	_data5_->self = g_object_ref (self);
	_tmp0_ = name;
	_tmp1_ = g_strdup (_tmp0_);
	_g_free0 (_data5_->name);
	_data5_->name = _tmp1_;
	_tmp2_ = combo;
	_tmp3_ = _g_object_ref0 (_tmp2_);
	_g_object_unref0 (_data5_->combo);
	_data5_->combo = _tmp3_;
	_tmp4_ = column;
	_data5_->column = _tmp4_;
	_tmp5_ = self->priv->preferences;
	_tmp6_ = _data5_->name;
	_tmp7_ = preferences_get (_tmp5_, _tmp6_);
	variant = _tmp7_;
	_tmp8_ = variant;
	_vala_assert (_tmp8_ != NULL, "variant != null");
	_tmp9_ = _data5_->combo;
	_tmp10_ = gtk_combo_box_get_model (_tmp9_);
	_tmp11_ = _g_object_ref0 (_tmp10_);
	model = _tmp11_;
	_tmp12_ = model;
	_tmp14_ = gtk_tree_model_get_iter_first (_tmp12_, &_tmp13_);
	iter = _tmp13_;
	if (_tmp14_) {
		GVariant* _tmp15_;
		const gchar* _tmp16_ = NULL;
		gchar* _tmp17_;
		gchar* str;
		_tmp15_ = variant;
		_tmp16_ = g_variant_get_string (_tmp15_, NULL);
		_tmp17_ = g_strdup (_tmp16_);
		str = _tmp17_;
		{
			gboolean _tmp18_;
			_tmp18_ = TRUE;
			while (TRUE) {
				gboolean _tmp19_;
				gchar* _str = NULL;
				GtkTreeModel* _tmp22_;
				GtkTreeIter _tmp23_;
				gint _tmp24_;
				const gchar* _tmp25_;
				const gchar* _tmp26_;
				_tmp19_ = _tmp18_;
				if (!_tmp19_) {
					GtkTreeModel* _tmp20_;
					gboolean _tmp21_ = FALSE;
					_tmp20_ = model;
					_tmp21_ = gtk_tree_model_iter_next (_tmp20_, &iter);
					if (!_tmp21_) {
						break;
					}
				}
				_tmp18_ = FALSE;
				_tmp22_ = model;
				_tmp23_ = iter;
				_tmp24_ = _data5_->column;
				gtk_tree_model_get (_tmp22_, &_tmp23_, _tmp24_, &_str, -1, -1);
				_tmp25_ = str;
				_tmp26_ = _str;
				if (g_strcmp0 (_tmp25_, _tmp26_) == 0) {
					GtkComboBox* _tmp27_;
					GtkTreeIter _tmp28_;
					_tmp27_ = _data5_->combo;
					_tmp28_ = iter;
					gtk_combo_box_set_active_iter (_tmp27_, &_tmp28_);
					_g_free0 (_str);
					break;
				}
				_g_free0 (_str);
			}
		}
		_g_free0 (str);
	}
	_tmp29_ = _data5_->combo;
	g_signal_connect_data (_tmp29_, "changed", (GCallback) ___lambda5__gtk_combo_box_changed, block5_data_ref (_data5_), (GClosureNotify) block5_data_unref, 0);
	_g_object_unref0 (model);
	_g_variant_unref0 (variant);
	block5_data_unref (_data5_);
	_data5_ = NULL;
}


static void setup_select_shortcut_section (Setup* self, KkcInputMode input_mode) {
	GtkTreeIter iter = {0};
	GtkTreeView* _tmp0_;
	GtkTreeModel* _tmp1_ = NULL;
	GtkTreeModel* _tmp2_;
	GtkTreeModel* model;
	GtkTreeModel* _tmp3_;
	GtkTreeIter _tmp4_ = {0};
	gboolean _tmp5_ = FALSE;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->input_mode_treeview;
	_tmp1_ = gtk_tree_view_get_model (_tmp0_);
	_tmp2_ = _g_object_ref0 (_tmp1_);
	model = _tmp2_;
	_tmp3_ = model;
	_tmp5_ = gtk_tree_model_get_iter_first (_tmp3_, &_tmp4_);
	iter = _tmp4_;
	if (_tmp5_) {
		{
			gboolean _tmp6_;
			_tmp6_ = TRUE;
			while (TRUE) {
				gboolean _tmp7_;
				gint _input_mode = 0;
				GtkTreeModel* _tmp10_;
				GtkTreeIter _tmp11_;
				gint _tmp12_;
				KkcInputMode _tmp13_;
				_tmp7_ = _tmp6_;
				if (!_tmp7_) {
					GtkTreeModel* _tmp8_;
					gboolean _tmp9_ = FALSE;
					_tmp8_ = model;
					_tmp9_ = gtk_tree_model_iter_next (_tmp8_, &iter);
					if (!_tmp9_) {
						break;
					}
				}
				_tmp6_ = FALSE;
				_tmp10_ = model;
				_tmp11_ = iter;
				gtk_tree_model_get (_tmp10_, &_tmp11_, 1, &_input_mode, -1, -1);
				_tmp12_ = _input_mode;
				_tmp13_ = input_mode;
				if (_tmp12_ == ((gint) _tmp13_)) {
					GtkTreeView* _tmp14_;
					GtkTreeSelection* _tmp15_ = NULL;
					GtkTreeSelection* _tmp16_;
					GtkTreeSelection* selection;
					GtkTreeSelection* _tmp17_;
					GtkTreeIter _tmp18_;
					_tmp14_ = self->priv->input_mode_treeview;
					_tmp15_ = gtk_tree_view_get_selection (_tmp14_);
					_tmp16_ = _g_object_ref0 (_tmp15_);
					selection = _tmp16_;
					_tmp17_ = selection;
					_tmp18_ = iter;
					gtk_tree_selection_select_iter (_tmp17_, &_tmp18_);
					_g_object_unref0 (selection);
					break;
				}
			}
		}
	}
	_g_object_unref0 (model);
}


static void setup_load (Setup* self) {
	GtkComboBox* _tmp0_;
	GtkComboBox* _tmp1_;
	GtkComboBox* _tmp2_;
	GtkCheckButton* _tmp3_;
	GtkCheckButton* _tmp4_;
	GtkComboBox* _tmp5_;
	GtkSpinButton* _tmp6_;
	GtkSpinButton* _tmp7_;
	GtkCheckButton* _tmp8_;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->typing_rule_combobox;
	setup_load_combobox_string (self, "typing_rule", _tmp0_, 0);
	_tmp1_ = self->priv->initial_input_mode_combobox;
	setup_load_combobox (self, "initial_input_mode", _tmp1_, 1);
	_tmp2_ = self->priv->punctuation_style_combobox;
	setup_load_combobox (self, "punctuation_style", _tmp2_, 1);
	_tmp3_ = self->priv->auto_correct_checkbutton;
	setup_load_togglebutton (self, "auto_correct", (GtkToggleButton*) _tmp3_);
	_tmp4_ = self->priv->use_custom_keymap_checkbutton;
	setup_load_togglebutton (self, "use_custom_keymap", (GtkToggleButton*) _tmp4_);
	_tmp5_ = self->priv->keymap_combobox;
	setup_load_combobox_string (self, "keymap", _tmp5_, 0);
	_tmp6_ = self->priv->page_size_spinbutton;
	setup_load_spinbutton (self, "page_size", _tmp6_);
	_tmp7_ = self->priv->pagination_start_spinbutton;
	setup_load_spinbutton (self, "pagination_start", _tmp7_);
	_tmp8_ = self->priv->show_annotation_checkbutton;
	setup_load_togglebutton (self, "show_annotation", (GtkToggleButton*) _tmp8_);
	setup_populate_dictionaries_treeview (self);
	setup_select_shortcut_section (self, KKC_INPUT_MODE_HIRAGANA);
}


static GVariant* _variant_new3 (gchar** value, gint value_length1) {
	gchar** _tmp23_;
	GVariantBuilder _tmp24_;
	int _tmp25_;
	_tmp23_ = value;
	g_variant_builder_init (&_tmp24_, G_VARIANT_TYPE ("as"));
	for (_tmp25_ = 0; _tmp25_ < value_length1; _tmp25_++) {
		g_variant_builder_add_value (&_tmp24_, g_variant_new_string (*_tmp23_));
		_tmp23_++;
	}
	return g_variant_ref_sink (g_variant_builder_end (&_tmp24_));
}


static void setup_save_dictionaries (Setup* self, const gchar* name) {
	GtkTreeView* _tmp0_;
	GtkTreeModel* _tmp1_ = NULL;
	GtkTreeModel* _tmp2_;
	GtkTreeModel* model;
	GtkTreeIter iter = {0};
	GtkTreeModel* _tmp3_;
	GtkTreeIter _tmp4_ = {0};
	gboolean _tmp5_ = FALSE;
	g_return_if_fail (self != NULL);
	g_return_if_fail (name != NULL);
	_tmp0_ = self->priv->dictionaries_treeview;
	_tmp1_ = gtk_tree_view_get_model (_tmp0_);
	_tmp2_ = _g_object_ref0 (_tmp1_);
	model = _tmp2_;
	_tmp3_ = model;
	_tmp5_ = gtk_tree_model_get_iter_first (_tmp3_, &_tmp4_);
	iter = _tmp4_;
	if (_tmp5_) {
		GeeArrayList* _tmp6_;
		GeeArrayList* dictionaries;
		Preferences* _tmp17_;
		const gchar* _tmp18_;
		GeeArrayList* _tmp19_;
		gint _tmp20_ = 0;
		gpointer* _tmp21_ = NULL;
		gchar** _tmp22_;
		gint _tmp22__length1;
		GVariant* _tmp26_;
		_tmp6_ = gee_array_list_new (G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, g_free, NULL);
		dictionaries = _tmp6_;
		{
			gboolean _tmp7_;
			_tmp7_ = TRUE;
			while (TRUE) {
				gboolean _tmp8_;
				DictionaryMetadata* metadata = NULL;
				GtkTreeModel* _tmp11_;
				GtkTreeIter _tmp12_;
				GeeArrayList* _tmp13_;
				DictionaryMetadata* _tmp14_;
				const gchar* _tmp15_;
				const gchar* _tmp16_;
				_tmp8_ = _tmp7_;
				if (!_tmp8_) {
					GtkTreeModel* _tmp9_;
					gboolean _tmp10_ = FALSE;
					_tmp9_ = model;
					_tmp10_ = gtk_tree_model_iter_next (_tmp9_, &iter);
					if (!_tmp10_) {
						break;
					}
				}
				_tmp7_ = FALSE;
				_tmp11_ = model;
				_tmp12_ = iter;
				gtk_tree_model_get (_tmp11_, &_tmp12_, 0, &metadata, -1, -1);
				_tmp13_ = dictionaries;
				_tmp14_ = metadata;
				_tmp15_ = dictionary_metadata_get_id (_tmp14_);
				_tmp16_ = _tmp15_;
				gee_abstract_collection_add ((GeeAbstractCollection*) _tmp13_, _tmp16_);
				_g_object_unref0 (metadata);
			}
		}
		_tmp17_ = self->priv->preferences;
		_tmp18_ = name;
		_tmp19_ = dictionaries;
		_tmp21_ = gee_abstract_collection_to_array ((GeeAbstractCollection*) _tmp19_, &_tmp20_);
		_tmp22_ = _tmp21_;
		_tmp22__length1 = _tmp20_;
		_tmp26_ = _variant_new3 (_tmp22_, _tmp20_);
		preferences_set (_tmp17_, _tmp18_, _tmp26_);
		_tmp22_ = (_vala_array_free (_tmp22_, _tmp22__length1, (GDestroyNotify) g_free), NULL);
		_g_object_unref0 (dictionaries);
	}
	_g_object_unref0 (model);
}


static GVariant* _variant_new4 (gint value) {
	return g_variant_ref_sink (g_variant_new_int32 (value));
}


static void setup_save_combobox (Setup* self, const gchar* name, GtkComboBox* combo, gint column) {
	GtkTreeIter iter = {0};
	GtkComboBox* _tmp0_;
	GtkTreeIter _tmp1_ = {0};
	gboolean _tmp2_ = FALSE;
	g_return_if_fail (self != NULL);
	g_return_if_fail (name != NULL);
	g_return_if_fail (combo != NULL);
	_tmp0_ = combo;
	_tmp2_ = gtk_combo_box_get_active_iter (_tmp0_, &_tmp1_);
	iter = _tmp1_;
	if (_tmp2_) {
		gint index = 0;
		GtkComboBox* _tmp3_;
		GtkTreeModel* _tmp4_ = NULL;
		GtkTreeModel* _tmp5_;
		GtkTreeModel* model;
		GtkTreeModel* _tmp6_;
		GtkTreeIter _tmp7_;
		gint _tmp8_;
		Preferences* _tmp9_;
		const gchar* _tmp10_;
		gint _tmp11_;
		GVariant* _tmp12_;
		_tmp3_ = combo;
		_tmp4_ = gtk_combo_box_get_model (_tmp3_);
		_tmp5_ = _g_object_ref0 (_tmp4_);
		model = _tmp5_;
		_tmp6_ = model;
		_tmp7_ = iter;
		_tmp8_ = column;
		gtk_tree_model_get (_tmp6_, &_tmp7_, _tmp8_, &index, -1, -1);
		_tmp9_ = self->priv->preferences;
		_tmp10_ = name;
		_tmp11_ = index;
		_tmp12_ = _variant_new4 (_tmp11_);
		preferences_set (_tmp9_, _tmp10_, _tmp12_);
		_g_object_unref0 (model);
	}
}


static GVariant* _variant_new5 (const gchar* value) {
	return g_variant_ref_sink (g_variant_new_string (value));
}


static void setup_save_combobox_string (Setup* self, const gchar* name, GtkComboBox* combo, gint column) {
	GtkTreeIter iter = {0};
	GtkComboBox* _tmp0_;
	GtkTreeIter _tmp1_ = {0};
	gboolean _tmp2_ = FALSE;
	g_return_if_fail (self != NULL);
	g_return_if_fail (name != NULL);
	g_return_if_fail (combo != NULL);
	_tmp0_ = combo;
	_tmp2_ = gtk_combo_box_get_active_iter (_tmp0_, &_tmp1_);
	iter = _tmp1_;
	if (_tmp2_) {
		gchar* str = NULL;
		GtkComboBox* _tmp3_;
		GtkTreeModel* _tmp4_ = NULL;
		GtkTreeModel* _tmp5_;
		GtkTreeModel* model;
		GtkTreeModel* _tmp6_;
		GtkTreeIter _tmp7_;
		gint _tmp8_;
		Preferences* _tmp9_;
		const gchar* _tmp10_;
		const gchar* _tmp11_;
		GVariant* _tmp12_;
		_tmp3_ = combo;
		_tmp4_ = gtk_combo_box_get_model (_tmp3_);
		_tmp5_ = _g_object_ref0 (_tmp4_);
		model = _tmp5_;
		_tmp6_ = model;
		_tmp7_ = iter;
		_tmp8_ = column;
		gtk_tree_model_get (_tmp6_, &_tmp7_, _tmp8_, &str, -1, -1);
		_tmp9_ = self->priv->preferences;
		_tmp10_ = name;
		_tmp11_ = str;
		_tmp12_ = _variant_new5 (_tmp11_);
		preferences_set (_tmp9_, _tmp10_, _tmp12_);
		_g_object_unref0 (model);
		_g_free0 (str);
	}
}


void setup_run (Setup* self) {
	GtkDialog* _tmp0_;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->dialog;
	gtk_dialog_run (_tmp0_);
}


gint setup_main (gchar** args, int args_length1) {
	gint result = 0;
	IBusBus* _tmp0_;
	IBusBus* bus;
	IBusBus* _tmp1_;
	gboolean _tmp2_ = FALSE;
	IBusBus* _tmp4_;
	IBusConfig* _tmp5_ = NULL;
	IBusConfig* _tmp6_;
	IBusConfig* config;
	IBusConfig* _tmp7_;
	IBusConfig* _tmp9_;
	Preferences* _tmp10_;
	Preferences* _tmp11_;
	Setup* _tmp12_;
	Setup* _tmp13_;
	Setup* setup;
	Setup* _tmp14_;
	ibus_init ();
	kkc_init ();
	gtk_init (&args_length1, &args);
	bindtextdomain (GETTEXT_PACKAGE, LOCALEDIR);
	bind_textdomain_codeset (GETTEXT_PACKAGE, "UTF-8");
	textdomain (GETTEXT_PACKAGE);
	_tmp0_ = ibus_bus_new ();
	g_object_ref_sink (_tmp0_);
	bus = _tmp0_;
	_tmp1_ = bus;
	_tmp2_ = ibus_bus_is_connected (_tmp1_);
	if (!_tmp2_) {
		FILE* _tmp3_;
		_tmp3_ = stderr;
		fprintf (_tmp3_, "cannot connect to ibus-daemon!\n");
		result = 1;
		_g_object_unref0 (bus);
		return result;
	}
	_tmp4_ = bus;
	_tmp5_ = ibus_bus_get_config (_tmp4_);
	_tmp6_ = _g_object_ref0 (_tmp5_);
	config = _tmp6_;
	_tmp7_ = config;
	if (_tmp7_ == NULL) {
		FILE* _tmp8_;
		_tmp8_ = stderr;
		fprintf (_tmp8_, "ibus-config component is not running!\n");
		result = 1;
		_g_object_unref0 (config);
		_g_object_unref0 (bus);
		return result;
	}
	_tmp9_ = config;
	_tmp10_ = preferences_new (_tmp9_);
	_tmp11_ = _tmp10_;
	_tmp12_ = setup_new (_tmp11_);
	_tmp13_ = _tmp12_;
	_g_object_unref0 (_tmp11_);
	setup = _tmp13_;
	_tmp14_ = setup;
	setup_run (_tmp14_);
	result = 0;
	_g_object_unref0 (setup);
	_g_object_unref0 (config);
	_g_object_unref0 (bus);
	return result;
}


int main (int argc, char ** argv) {
	g_type_init ();
	return setup_main (argv, argc);
}


static SetupDictCellRenderer* setup_dict_cell_renderer_construct (GType object_type) {
	SetupDictCellRenderer * self = NULL;
	self = (SetupDictCellRenderer*) g_object_new (object_type, NULL);
	return self;
}


static SetupDictCellRenderer* setup_dict_cell_renderer_new (void) {
	return setup_dict_cell_renderer_construct (SETUP_TYPE_DICT_CELL_RENDERER);
}


static DictionaryMetadata* setup_dict_cell_renderer_get_metadata (SetupDictCellRenderer* self) {
	DictionaryMetadata* result;
	DictionaryMetadata* _tmp0_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_metadata;
	result = _tmp0_;
	return result;
}


static void setup_dict_cell_renderer_set_metadata (SetupDictCellRenderer* self, DictionaryMetadata* value) {
	DictionaryMetadata* _tmp0_;
	DictionaryMetadata* _tmp1_;
	DictionaryMetadata* _tmp2_;
	const gchar* _tmp3_;
	const gchar* _tmp4_;
	const gchar* _tmp5_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	_tmp1_ = _g_object_ref0 (_tmp0_);
	_g_object_unref0 (self->priv->_metadata);
	self->priv->_metadata = _tmp1_;
	_tmp2_ = self->priv->_metadata;
	_tmp3_ = dictionary_metadata_get_name (_tmp2_);
	_tmp4_ = _tmp3_;
	_tmp5_ = g_dgettext (NULL, _tmp4_);
	g_object_set ((GtkCellRendererText*) self, "text", _tmp5_, NULL);
	g_object_notify ((GObject *) self, "metadata");
}


static void setup_dict_cell_renderer_class_init (SetupDictCellRendererClass * klass) {
	setup_dict_cell_renderer_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (SetupDictCellRendererPrivate));
	G_OBJECT_CLASS (klass)->get_property = _vala_setup_dict_cell_renderer_get_property;
	G_OBJECT_CLASS (klass)->set_property = _vala_setup_dict_cell_renderer_set_property;
	G_OBJECT_CLASS (klass)->finalize = setup_dict_cell_renderer_finalize;
	g_object_class_install_property (G_OBJECT_CLASS (klass), SETUP_DICT_CELL_RENDERER_METADATA, g_param_spec_object ("metadata", "metadata", "metadata", TYPE_DICTIONARY_METADATA, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
}


static void setup_dict_cell_renderer_instance_init (SetupDictCellRenderer * self) {
	self->priv = SETUP_DICT_CELL_RENDERER_GET_PRIVATE (self);
}


static void setup_dict_cell_renderer_finalize (GObject* obj) {
	SetupDictCellRenderer * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, SETUP_TYPE_DICT_CELL_RENDERER, SetupDictCellRenderer);
	_g_object_unref0 (self->priv->_metadata);
	G_OBJECT_CLASS (setup_dict_cell_renderer_parent_class)->finalize (obj);
}


static GType setup_dict_cell_renderer_get_type (void) {
	static volatile gsize setup_dict_cell_renderer_type_id__volatile = 0;
	if (g_once_init_enter (&setup_dict_cell_renderer_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (SetupDictCellRendererClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) setup_dict_cell_renderer_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (SetupDictCellRenderer), 0, (GInstanceInitFunc) setup_dict_cell_renderer_instance_init, NULL };
		GType setup_dict_cell_renderer_type_id;
		setup_dict_cell_renderer_type_id = g_type_register_static (GTK_TYPE_CELL_RENDERER_TEXT, "SetupDictCellRenderer", &g_define_type_info, 0);
		g_once_init_leave (&setup_dict_cell_renderer_type_id__volatile, setup_dict_cell_renderer_type_id);
	}
	return setup_dict_cell_renderer_type_id__volatile;
}


static void _vala_setup_dict_cell_renderer_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec) {
	SetupDictCellRenderer * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, SETUP_TYPE_DICT_CELL_RENDERER, SetupDictCellRenderer);
	switch (property_id) {
		case SETUP_DICT_CELL_RENDERER_METADATA:
		g_value_set_object (value, setup_dict_cell_renderer_get_metadata (self));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static void _vala_setup_dict_cell_renderer_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec) {
	SetupDictCellRenderer * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, SETUP_TYPE_DICT_CELL_RENDERER, SetupDictCellRenderer);
	switch (property_id) {
		case SETUP_DICT_CELL_RENDERER_METADATA:
		setup_dict_cell_renderer_set_metadata (self, g_value_get_object (value));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static SetupKeyEventCellRenderer* setup_key_event_cell_renderer_construct (GType object_type) {
	SetupKeyEventCellRenderer * self = NULL;
	self = (SetupKeyEventCellRenderer*) g_object_new (object_type, NULL);
	return self;
}


static SetupKeyEventCellRenderer* setup_key_event_cell_renderer_new (void) {
	return setup_key_event_cell_renderer_construct (SETUP_TYPE_KEY_EVENT_CELL_RENDERER);
}


static KkcKeyEvent* setup_key_event_cell_renderer_get_event (SetupKeyEventCellRenderer* self) {
	KkcKeyEvent* result;
	KkcKeyEvent* _tmp0_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_event;
	result = _tmp0_;
	return result;
}


static void setup_key_event_cell_renderer_set_event (SetupKeyEventCellRenderer* self, KkcKeyEvent* value) {
	KkcKeyEvent* _tmp0_;
	KkcKeyEvent* _tmp1_;
	KkcKeyEvent* _tmp2_;
	gboolean _tmp12_ = FALSE;
	GdkModifierType _tmp13_ = 0;
	GdkModifierType _tmp14_;
	gboolean _tmp17_;
	g_return_if_fail (self != NULL);
	g_object_set ((GtkCellRendererAccel*) self, "accel-mode", GTK_CELL_RENDERER_ACCEL_MODE_OTHER, NULL);
	_tmp0_ = value;
	_tmp1_ = _g_object_ref0 (_tmp0_);
	_g_object_unref0 (self->priv->_event);
	self->priv->_event = _tmp1_;
	_tmp2_ = self->priv->_event;
	if (_tmp2_ == NULL) {
		g_object_set ((GtkCellRendererAccel*) self, "accel-key", (guint) 0, NULL);
		g_object_set ((GtkCellRendererAccel*) self, "accel-mods", 0, NULL);
		g_object_set ((GtkCellRendererAccel*) self, "keycode", (guint) 0, NULL);
	} else {
		KkcKeyEvent* _tmp3_;
		guint _tmp4_;
		guint _tmp5_;
		KkcKeyEvent* _tmp6_;
		KkcModifierType _tmp7_;
		KkcModifierType _tmp8_;
		KkcKeyEvent* _tmp9_;
		guint _tmp10_;
		guint _tmp11_;
		_tmp3_ = self->priv->_event;
		_tmp4_ = kkc_key_event_get_keyval (_tmp3_);
		_tmp5_ = _tmp4_;
		g_object_set ((GtkCellRendererAccel*) self, "accel-key", _tmp5_, NULL);
		_tmp6_ = self->priv->_event;
		_tmp7_ = kkc_key_event_get_modifiers (_tmp6_);
		_tmp8_ = _tmp7_;
		g_object_set ((GtkCellRendererAccel*) self, "accel-mods", (GdkModifierType) _tmp8_, NULL);
		_tmp9_ = self->priv->_event;
		_tmp10_ = kkc_key_event_get_keycode (_tmp9_);
		_tmp11_ = _tmp10_;
		g_object_set ((GtkCellRendererAccel*) self, "keycode", _tmp11_, NULL);
	}
	g_object_get ((GtkCellRendererAccel*) self, "accel-mods", &_tmp13_, NULL);
	_tmp14_ = _tmp13_;
	if (_tmp14_ == 0) {
		guint _tmp15_ = 0U;
		guint _tmp16_;
		g_object_get ((GtkCellRendererAccel*) self, "accel-key", &_tmp15_, NULL);
		_tmp16_ = _tmp15_;
		_tmp12_ = _vala_uint_array_contains (SETUP_IGNORED_KEYVALS, G_N_ELEMENTS (SETUP_IGNORED_KEYVALS), _tmp16_);
	} else {
		_tmp12_ = FALSE;
	}
	_tmp17_ = _tmp12_;
	if (_tmp17_) {
		g_object_set ((GtkCellRendererText*) self, "editable", FALSE, NULL);
	} else {
		g_object_set ((GtkCellRendererText*) self, "editable", TRUE, NULL);
	}
	g_object_notify ((GObject *) self, "event");
}


static void setup_key_event_cell_renderer_class_init (SetupKeyEventCellRendererClass * klass) {
	setup_key_event_cell_renderer_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (SetupKeyEventCellRendererPrivate));
	G_OBJECT_CLASS (klass)->get_property = _vala_setup_key_event_cell_renderer_get_property;
	G_OBJECT_CLASS (klass)->set_property = _vala_setup_key_event_cell_renderer_set_property;
	G_OBJECT_CLASS (klass)->finalize = setup_key_event_cell_renderer_finalize;
	g_object_class_install_property (G_OBJECT_CLASS (klass), SETUP_KEY_EVENT_CELL_RENDERER_EVENT, g_param_spec_object ("event", "event", "event", KKC_TYPE_KEY_EVENT, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
}


static void setup_key_event_cell_renderer_instance_init (SetupKeyEventCellRenderer * self) {
	self->priv = SETUP_KEY_EVENT_CELL_RENDERER_GET_PRIVATE (self);
}


static void setup_key_event_cell_renderer_finalize (GObject* obj) {
	SetupKeyEventCellRenderer * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, SETUP_TYPE_KEY_EVENT_CELL_RENDERER, SetupKeyEventCellRenderer);
	_g_object_unref0 (self->priv->_event);
	G_OBJECT_CLASS (setup_key_event_cell_renderer_parent_class)->finalize (obj);
}


static GType setup_key_event_cell_renderer_get_type (void) {
	static volatile gsize setup_key_event_cell_renderer_type_id__volatile = 0;
	if (g_once_init_enter (&setup_key_event_cell_renderer_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (SetupKeyEventCellRendererClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) setup_key_event_cell_renderer_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (SetupKeyEventCellRenderer), 0, (GInstanceInitFunc) setup_key_event_cell_renderer_instance_init, NULL };
		GType setup_key_event_cell_renderer_type_id;
		setup_key_event_cell_renderer_type_id = g_type_register_static (GTK_TYPE_CELL_RENDERER_ACCEL, "SetupKeyEventCellRenderer", &g_define_type_info, 0);
		g_once_init_leave (&setup_key_event_cell_renderer_type_id__volatile, setup_key_event_cell_renderer_type_id);
	}
	return setup_key_event_cell_renderer_type_id__volatile;
}


static void _vala_setup_key_event_cell_renderer_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec) {
	SetupKeyEventCellRenderer * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, SETUP_TYPE_KEY_EVENT_CELL_RENDERER, SetupKeyEventCellRenderer);
	switch (property_id) {
		case SETUP_KEY_EVENT_CELL_RENDERER_EVENT:
		g_value_set_object (value, setup_key_event_cell_renderer_get_event (self));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static void _vala_setup_key_event_cell_renderer_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec) {
	SetupKeyEventCellRenderer * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, SETUP_TYPE_KEY_EVENT_CELL_RENDERER, SetupKeyEventCellRenderer);
	switch (property_id) {
		case SETUP_KEY_EVENT_CELL_RENDERER_EVENT:
		setup_key_event_cell_renderer_set_event (self, g_value_get_object (value));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static void setup_class_init (SetupClass * klass) {
	setup_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (SetupPrivate));
	G_OBJECT_CLASS (klass)->finalize = setup_finalize;
}


static void setup_instance_init (Setup * self) {
	self->priv = SETUP_GET_PRIVATE (self);
}


static void setup_finalize (GObject* obj) {
	Setup * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_SETUP, Setup);
	_g_object_unref0 (self->priv->dialog);
	_g_object_unref0 (self->priv->dictionaries_treeview);
	_g_object_unref0 (self->priv->available_dictionaries_treeview);
	_g_object_unref0 (self->priv->punctuation_style_combobox);
	_g_object_unref0 (self->priv->auto_correct_checkbutton);
	_g_object_unref0 (self->priv->use_custom_keymap_checkbutton);
	_g_object_unref0 (self->priv->keymap_combobox);
	_g_object_unref0 (self->priv->page_size_spinbutton);
	_g_object_unref0 (self->priv->pagination_start_spinbutton);
	_g_object_unref0 (self->priv->show_annotation_checkbutton);
	_g_object_unref0 (self->priv->initial_input_mode_combobox);
	_g_object_unref0 (self->priv->typing_rule_combobox);
	_g_object_unref0 (self->priv->input_mode_treeview);
	_g_object_unref0 (self->priv->shortcut_treeview);
	_g_object_unref0 (self->priv->add_shortcut_toolbutton);
	_g_object_unref0 (self->priv->remove_shortcut_toolbutton);
	_g_object_unref0 (self->priv->dict_dialog);
	_g_object_unref0 (self->priv->shortcut_dialog);
	_g_object_unref0 (self->priv->shortcut_command_combobox);
	_g_object_unref0 (self->priv->preferences);
	_g_object_unref0 (self->priv->shortcut_rule);
	G_OBJECT_CLASS (setup_parent_class)->finalize (obj);
}


GType setup_get_type (void) {
	static volatile gsize setup_type_id__volatile = 0;
	if (g_once_init_enter (&setup_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (SetupClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) setup_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (Setup), 0, (GInstanceInitFunc) setup_instance_init, NULL };
		GType setup_type_id;
		setup_type_id = g_type_register_static (G_TYPE_OBJECT, "Setup", &g_define_type_info, 0);
		g_once_init_leave (&setup_type_id__volatile, setup_type_id);
	}
	return setup_type_id__volatile;
}


static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	if ((array != NULL) && (destroy_func != NULL)) {
		int i;
		for (i = 0; i < array_length; i = i + 1) {
			if (((gpointer*) array)[i] != NULL) {
				destroy_func (((gpointer*) array)[i]);
			}
		}
	}
}


static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	_vala_array_destroy (array, array_length, destroy_func);
	g_free (array);
}



