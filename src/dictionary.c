/* dictionary.c generated by valac 0.20.1, the Vala compiler
 * generated from dictionary.vala, do not modify */

/* 
 * Copyright (C) 2011-2013 Daiki Ueno <ueno@gnu.org>
 * Copyright (C) 2011-2013 Red Hat, Inc.
 * 
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

#include <glib.h>
#include <glib-object.h>
#include <stdlib.h>
#include <string.h>
#include <json-glib/json-glib.h>
#include <gee.h>
#include <gio/gio.h>
#include <glib/gstdio.h>
#include <config.h>


#define TYPE_DICTIONARY_METADATA (dictionary_metadata_get_type ())
#define DICTIONARY_METADATA(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_DICTIONARY_METADATA, DictionaryMetadata))
#define DICTIONARY_METADATA_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_DICTIONARY_METADATA, DictionaryMetadataClass))
#define IS_DICTIONARY_METADATA(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_DICTIONARY_METADATA))
#define IS_DICTIONARY_METADATA_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_DICTIONARY_METADATA))
#define DICTIONARY_METADATA_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_DICTIONARY_METADATA, DictionaryMetadataClass))

typedef struct _DictionaryMetadata DictionaryMetadata;
typedef struct _DictionaryMetadataClass DictionaryMetadataClass;
typedef struct _DictionaryMetadataPrivate DictionaryMetadataPrivate;
#define _g_free0(var) (var = (g_free (var), NULL))

#define TYPE_DICTIONARY_REGISTRY (dictionary_registry_get_type ())
#define DICTIONARY_REGISTRY(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_DICTIONARY_REGISTRY, DictionaryRegistry))
#define DICTIONARY_REGISTRY_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_DICTIONARY_REGISTRY, DictionaryRegistryClass))
#define IS_DICTIONARY_REGISTRY(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_DICTIONARY_REGISTRY))
#define IS_DICTIONARY_REGISTRY_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_DICTIONARY_REGISTRY))
#define DICTIONARY_REGISTRY_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_DICTIONARY_REGISTRY, DictionaryRegistryClass))

typedef struct _DictionaryRegistry DictionaryRegistry;
typedef struct _DictionaryRegistryClass DictionaryRegistryClass;
typedef struct _DictionaryRegistryPrivate DictionaryRegistryPrivate;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))
#define __vala_JsonNode_free0(var) ((var == NULL) ? NULL : (var = (_vala_JsonNode_free (var), NULL)))
#define __vala_JsonObject_free0(var) ((var == NULL) ? NULL : (var = (_vala_JsonObject_free (var), NULL)))
#define __vala_JsonArray_free0(var) ((var == NULL) ? NULL : (var = (_vala_JsonArray_free (var), NULL)))

struct _DictionaryMetadata {
	GObject parent_instance;
	DictionaryMetadataPrivate * priv;
};

struct _DictionaryMetadataClass {
	GObjectClass parent_class;
};

struct _DictionaryMetadataPrivate {
	gchar* _id;
	gchar* _filename;
	gchar* _name;
	gchar* _description;
	gchar* _encoding;
	gboolean _default_enabled;
};

struct _DictionaryRegistry {
	GObject parent_instance;
	DictionaryRegistryPrivate * priv;
};

struct _DictionaryRegistryClass {
	GObjectClass parent_class;
};

struct _DictionaryRegistryPrivate {
	GeeMap* available_metadata;
	GeeList* available;
};


static gpointer dictionary_metadata_parent_class = NULL;
static gpointer dictionary_registry_parent_class = NULL;

GType dictionary_metadata_get_type (void) G_GNUC_CONST;
#define DICTIONARY_METADATA_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), TYPE_DICTIONARY_METADATA, DictionaryMetadataPrivate))
enum  {
	DICTIONARY_METADATA_DUMMY_PROPERTY,
	DICTIONARY_METADATA_ID,
	DICTIONARY_METADATA_FILENAME,
	DICTIONARY_METADATA_NAME,
	DICTIONARY_METADATA_DESCRIPTION,
	DICTIONARY_METADATA_ENCODING,
	DICTIONARY_METADATA_DEFAULT_ENABLED
};
DictionaryMetadata* dictionary_metadata_new_from_json_object (JsonObject* object);
DictionaryMetadata* dictionary_metadata_construct_from_json_object (GType object_type, JsonObject* object);
DictionaryMetadata* dictionary_metadata_new (void);
DictionaryMetadata* dictionary_metadata_construct (GType object_type);
const gchar* dictionary_metadata_get_id (DictionaryMetadata* self);
void dictionary_metadata_set_id (DictionaryMetadata* self, const gchar* value);
const gchar* dictionary_metadata_get_filename (DictionaryMetadata* self);
void dictionary_metadata_set_filename (DictionaryMetadata* self, const gchar* value);
const gchar* dictionary_metadata_get_name (DictionaryMetadata* self);
void dictionary_metadata_set_name (DictionaryMetadata* self, const gchar* value);
const gchar* dictionary_metadata_get_description (DictionaryMetadata* self);
void dictionary_metadata_set_description (DictionaryMetadata* self, const gchar* value);
const gchar* dictionary_metadata_get_encoding (DictionaryMetadata* self);
void dictionary_metadata_set_encoding (DictionaryMetadata* self, const gchar* value);
gboolean dictionary_metadata_get_default_enabled (DictionaryMetadata* self);
void dictionary_metadata_set_default_enabled (DictionaryMetadata* self, gboolean value);
static void dictionary_metadata_finalize (GObject* obj);
static void _vala_dictionary_metadata_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec);
static void _vala_dictionary_metadata_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec);
GType dictionary_registry_get_type (void) G_GNUC_CONST;
#define DICTIONARY_REGISTRY_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), TYPE_DICTIONARY_REGISTRY, DictionaryRegistryPrivate))
enum  {
	DICTIONARY_REGISTRY_DUMMY_PROPERTY
};
static void dictionary_registry_load_metadata_from_stream (DictionaryRegistry* self, GInputStream* stream);
static JsonNode* _vala_JsonNode_copy (JsonNode* self);
static JsonArray* _vala_JsonArray_copy (JsonArray* self);
static void _vala_JsonNode_free (JsonNode* self);
static JsonObject* _vala_JsonObject_copy (JsonObject* self);
static void _vala_JsonObject_free (JsonObject* self);
static void _vala_JsonArray_free (JsonArray* self);
DictionaryMetadata** dictionary_registry_list_available (DictionaryRegistry* self, int* result_length1);
DictionaryMetadata* dictionary_registry_get_metadata (DictionaryRegistry* self, const gchar* id);
DictionaryRegistry* dictionary_registry_new (void);
DictionaryRegistry* dictionary_registry_construct (GType object_type);
static void dictionary_registry_finalize (GObject* obj);


DictionaryMetadata* dictionary_metadata_construct_from_json_object (GType object_type, JsonObject* object) {
	DictionaryMetadata * self = NULL;
	JsonObject* _tmp0_;
	const gchar* _tmp1_ = NULL;
	gchar* _tmp2_;
	gchar* id;
	JsonObject* _tmp3_;
	const gchar* _tmp4_ = NULL;
	gchar* _tmp5_;
	gchar* filename;
	JsonObject* _tmp6_;
	const gchar* _tmp7_ = NULL;
	gchar* _tmp8_;
	gchar* name;
	JsonObject* _tmp9_;
	const gchar* _tmp10_ = NULL;
	gchar* _tmp11_;
	gchar* description;
	gboolean default_enabled;
	JsonObject* _tmp12_;
	gboolean _tmp13_ = FALSE;
	gchar* _tmp16_;
	gchar* encoding;
	JsonObject* _tmp17_;
	gboolean _tmp18_ = FALSE;
	const gchar* _tmp22_;
	const gchar* _tmp23_;
	const gchar* _tmp24_;
	const gchar* _tmp25_;
	gboolean _tmp26_;
	const gchar* _tmp27_;
	g_return_val_if_fail (object != NULL, NULL);
	_tmp0_ = object;
	_tmp1_ = json_object_get_string_member (_tmp0_, "id");
	_tmp2_ = g_strdup (_tmp1_);
	id = _tmp2_;
	_tmp3_ = object;
	_tmp4_ = json_object_get_string_member (_tmp3_, "filename");
	_tmp5_ = g_strdup (_tmp4_);
	filename = _tmp5_;
	_tmp6_ = object;
	_tmp7_ = json_object_get_string_member (_tmp6_, "name");
	_tmp8_ = g_strdup (_tmp7_);
	name = _tmp8_;
	_tmp9_ = object;
	_tmp10_ = json_object_get_string_member (_tmp9_, "description");
	_tmp11_ = g_strdup (_tmp10_);
	description = _tmp11_;
	default_enabled = FALSE;
	_tmp12_ = object;
	_tmp13_ = json_object_has_member (_tmp12_, "default_enabled");
	if (_tmp13_) {
		JsonObject* _tmp14_;
		gboolean _tmp15_ = FALSE;
		_tmp14_ = object;
		_tmp15_ = json_object_get_boolean_member (_tmp14_, "default_enabled");
		default_enabled = _tmp15_;
	}
	_tmp16_ = g_strdup ("EUC-JP");
	encoding = _tmp16_;
	_tmp17_ = object;
	_tmp18_ = json_object_has_member (_tmp17_, "encoding");
	if (_tmp18_) {
		JsonObject* _tmp19_;
		const gchar* _tmp20_ = NULL;
		gchar* _tmp21_;
		_tmp19_ = object;
		_tmp20_ = json_object_get_string_member (_tmp19_, "encoding");
		_tmp21_ = g_strdup (_tmp20_);
		_g_free0 (encoding);
		encoding = _tmp21_;
	}
	_tmp22_ = id;
	_tmp23_ = filename;
	_tmp24_ = name;
	_tmp25_ = description;
	_tmp26_ = default_enabled;
	_tmp27_ = encoding;
	self = (DictionaryMetadata*) g_object_new (object_type, "id", _tmp22_, "filename", _tmp23_, "name", _tmp24_, "description", _tmp25_, "default-enabled", _tmp26_, "encoding", _tmp27_, NULL);
	_g_free0 (encoding);
	_g_free0 (description);
	_g_free0 (name);
	_g_free0 (filename);
	_g_free0 (id);
	return self;
}


DictionaryMetadata* dictionary_metadata_new_from_json_object (JsonObject* object) {
	return dictionary_metadata_construct_from_json_object (TYPE_DICTIONARY_METADATA, object);
}


DictionaryMetadata* dictionary_metadata_construct (GType object_type) {
	DictionaryMetadata * self = NULL;
	self = (DictionaryMetadata*) g_object_new (object_type, NULL);
	return self;
}


DictionaryMetadata* dictionary_metadata_new (void) {
	return dictionary_metadata_construct (TYPE_DICTIONARY_METADATA);
}


const gchar* dictionary_metadata_get_id (DictionaryMetadata* self) {
	const gchar* result;
	const gchar* _tmp0_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_id;
	result = _tmp0_;
	return result;
}


void dictionary_metadata_set_id (DictionaryMetadata* self, const gchar* value) {
	const gchar* _tmp0_;
	gchar* _tmp1_;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	_tmp1_ = g_strdup (_tmp0_);
	_g_free0 (self->priv->_id);
	self->priv->_id = _tmp1_;
	g_object_notify ((GObject *) self, "id");
}


const gchar* dictionary_metadata_get_filename (DictionaryMetadata* self) {
	const gchar* result;
	const gchar* _tmp0_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_filename;
	result = _tmp0_;
	return result;
}


void dictionary_metadata_set_filename (DictionaryMetadata* self, const gchar* value) {
	const gchar* _tmp0_;
	gchar* _tmp1_;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	_tmp1_ = g_strdup (_tmp0_);
	_g_free0 (self->priv->_filename);
	self->priv->_filename = _tmp1_;
	g_object_notify ((GObject *) self, "filename");
}


const gchar* dictionary_metadata_get_name (DictionaryMetadata* self) {
	const gchar* result;
	const gchar* _tmp0_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_name;
	result = _tmp0_;
	return result;
}


void dictionary_metadata_set_name (DictionaryMetadata* self, const gchar* value) {
	const gchar* _tmp0_;
	gchar* _tmp1_;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	_tmp1_ = g_strdup (_tmp0_);
	_g_free0 (self->priv->_name);
	self->priv->_name = _tmp1_;
	g_object_notify ((GObject *) self, "name");
}


const gchar* dictionary_metadata_get_description (DictionaryMetadata* self) {
	const gchar* result;
	const gchar* _tmp0_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_description;
	result = _tmp0_;
	return result;
}


void dictionary_metadata_set_description (DictionaryMetadata* self, const gchar* value) {
	const gchar* _tmp0_;
	gchar* _tmp1_;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	_tmp1_ = g_strdup (_tmp0_);
	_g_free0 (self->priv->_description);
	self->priv->_description = _tmp1_;
	g_object_notify ((GObject *) self, "description");
}


const gchar* dictionary_metadata_get_encoding (DictionaryMetadata* self) {
	const gchar* result;
	const gchar* _tmp0_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_encoding;
	result = _tmp0_;
	return result;
}


void dictionary_metadata_set_encoding (DictionaryMetadata* self, const gchar* value) {
	const gchar* _tmp0_;
	gchar* _tmp1_;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	_tmp1_ = g_strdup (_tmp0_);
	_g_free0 (self->priv->_encoding);
	self->priv->_encoding = _tmp1_;
	g_object_notify ((GObject *) self, "encoding");
}


gboolean dictionary_metadata_get_default_enabled (DictionaryMetadata* self) {
	gboolean result;
	gboolean _tmp0_;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = self->priv->_default_enabled;
	result = _tmp0_;
	return result;
}


void dictionary_metadata_set_default_enabled (DictionaryMetadata* self, gboolean value) {
	gboolean _tmp0_;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	self->priv->_default_enabled = _tmp0_;
	g_object_notify ((GObject *) self, "default-enabled");
}


static void dictionary_metadata_class_init (DictionaryMetadataClass * klass) {
	dictionary_metadata_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (DictionaryMetadataPrivate));
	G_OBJECT_CLASS (klass)->get_property = _vala_dictionary_metadata_get_property;
	G_OBJECT_CLASS (klass)->set_property = _vala_dictionary_metadata_set_property;
	G_OBJECT_CLASS (klass)->finalize = dictionary_metadata_finalize;
	g_object_class_install_property (G_OBJECT_CLASS (klass), DICTIONARY_METADATA_ID, g_param_spec_string ("id", "id", "id", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT));
	g_object_class_install_property (G_OBJECT_CLASS (klass), DICTIONARY_METADATA_FILENAME, g_param_spec_string ("filename", "filename", "filename", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT));
	g_object_class_install_property (G_OBJECT_CLASS (klass), DICTIONARY_METADATA_NAME, g_param_spec_string ("name", "name", "name", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT));
	g_object_class_install_property (G_OBJECT_CLASS (klass), DICTIONARY_METADATA_DESCRIPTION, g_param_spec_string ("description", "description", "description", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT));
	g_object_class_install_property (G_OBJECT_CLASS (klass), DICTIONARY_METADATA_ENCODING, g_param_spec_string ("encoding", "encoding", "encoding", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT));
	g_object_class_install_property (G_OBJECT_CLASS (klass), DICTIONARY_METADATA_DEFAULT_ENABLED, g_param_spec_boolean ("default-enabled", "default-enabled", "default-enabled", FALSE, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT));
}


static void dictionary_metadata_instance_init (DictionaryMetadata * self) {
	gchar* _tmp0_;
	self->priv = DICTIONARY_METADATA_GET_PRIVATE (self);
	_tmp0_ = g_strdup ("EUC-JP");
	self->priv->_encoding = _tmp0_;
	self->priv->_default_enabled = FALSE;
}


static void dictionary_metadata_finalize (GObject* obj) {
	DictionaryMetadata * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_DICTIONARY_METADATA, DictionaryMetadata);
	_g_free0 (self->priv->_id);
	_g_free0 (self->priv->_filename);
	_g_free0 (self->priv->_name);
	_g_free0 (self->priv->_description);
	_g_free0 (self->priv->_encoding);
	G_OBJECT_CLASS (dictionary_metadata_parent_class)->finalize (obj);
}


GType dictionary_metadata_get_type (void) {
	static volatile gsize dictionary_metadata_type_id__volatile = 0;
	if (g_once_init_enter (&dictionary_metadata_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (DictionaryMetadataClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) dictionary_metadata_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (DictionaryMetadata), 0, (GInstanceInitFunc) dictionary_metadata_instance_init, NULL };
		GType dictionary_metadata_type_id;
		dictionary_metadata_type_id = g_type_register_static (G_TYPE_OBJECT, "DictionaryMetadata", &g_define_type_info, 0);
		g_once_init_leave (&dictionary_metadata_type_id__volatile, dictionary_metadata_type_id);
	}
	return dictionary_metadata_type_id__volatile;
}


static void _vala_dictionary_metadata_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec) {
	DictionaryMetadata * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, TYPE_DICTIONARY_METADATA, DictionaryMetadata);
	switch (property_id) {
		case DICTIONARY_METADATA_ID:
		g_value_set_string (value, dictionary_metadata_get_id (self));
		break;
		case DICTIONARY_METADATA_FILENAME:
		g_value_set_string (value, dictionary_metadata_get_filename (self));
		break;
		case DICTIONARY_METADATA_NAME:
		g_value_set_string (value, dictionary_metadata_get_name (self));
		break;
		case DICTIONARY_METADATA_DESCRIPTION:
		g_value_set_string (value, dictionary_metadata_get_description (self));
		break;
		case DICTIONARY_METADATA_ENCODING:
		g_value_set_string (value, dictionary_metadata_get_encoding (self));
		break;
		case DICTIONARY_METADATA_DEFAULT_ENABLED:
		g_value_set_boolean (value, dictionary_metadata_get_default_enabled (self));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static void _vala_dictionary_metadata_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec) {
	DictionaryMetadata * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, TYPE_DICTIONARY_METADATA, DictionaryMetadata);
	switch (property_id) {
		case DICTIONARY_METADATA_ID:
		dictionary_metadata_set_id (self, g_value_get_string (value));
		break;
		case DICTIONARY_METADATA_FILENAME:
		dictionary_metadata_set_filename (self, g_value_get_string (value));
		break;
		case DICTIONARY_METADATA_NAME:
		dictionary_metadata_set_name (self, g_value_get_string (value));
		break;
		case DICTIONARY_METADATA_DESCRIPTION:
		dictionary_metadata_set_description (self, g_value_get_string (value));
		break;
		case DICTIONARY_METADATA_ENCODING:
		dictionary_metadata_set_encoding (self, g_value_get_string (value));
		break;
		case DICTIONARY_METADATA_DEFAULT_ENABLED:
		dictionary_metadata_set_default_enabled (self, g_value_get_boolean (value));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static JsonNode* _vala_JsonNode_copy (JsonNode* self) {
	return g_boxed_copy (json_node_get_type (), self);
}


static gpointer __vala_JsonNode_copy0 (gpointer self) {
	return self ? _vala_JsonNode_copy (self) : NULL;
}


static JsonArray* _vala_JsonArray_copy (JsonArray* self) {
	return g_boxed_copy (json_array_get_type (), self);
}


static gpointer __vala_JsonArray_copy0 (gpointer self) {
	return self ? _vala_JsonArray_copy (self) : NULL;
}


static void _vala_JsonNode_free (JsonNode* self) {
	g_boxed_free (json_node_get_type (), self);
}


static JsonObject* _vala_JsonObject_copy (JsonObject* self) {
	return g_boxed_copy (json_object_get_type (), self);
}


static gpointer __vala_JsonObject_copy0 (gpointer self) {
	return self ? _vala_JsonObject_copy (self) : NULL;
}


static void _vala_JsonObject_free (JsonObject* self) {
	g_boxed_free (json_object_get_type (), self);
}


static void _vala_JsonArray_free (JsonArray* self) {
	g_boxed_free (json_array_get_type (), self);
}


static void dictionary_registry_load_metadata_from_stream (DictionaryRegistry* self, GInputStream* stream) {
	JsonParser* _tmp0_;
	JsonParser* parser;
	JsonNode* _tmp3_ = NULL;
	JsonNode* _tmp4_;
	JsonNode* root;
	JsonNodeType _tmp5_ = 0;
	JsonArray* _tmp6_ = NULL;
	JsonArray* _tmp7_;
	JsonArray* array;
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (stream != NULL);
	_tmp0_ = json_parser_new ();
	parser = _tmp0_;
	{
		GInputStream* _tmp1_;
		_tmp1_ = stream;
		json_parser_load_from_stream (parser, _tmp1_, NULL, &_inner_error_);
		if (_inner_error_ != NULL) {
			goto __catch0_g_error;
		}
	}
	goto __finally0;
	__catch0_g_error:
	{
		GError* e = NULL;
		const gchar* _tmp2_;
		e = _inner_error_;
		_inner_error_ = NULL;
		_tmp2_ = e->message;
		g_error ("dictionary.vala:65: failed to parse JSON: %s", _tmp2_);
		_g_error_free0 (e);
	}
	__finally0:
	if (_inner_error_ != NULL) {
		_g_object_unref0 (parser);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
	_tmp3_ = json_parser_get_root (parser);
	_tmp4_ = __vala_JsonNode_copy0 (_tmp3_);
	root = _tmp4_;
	_tmp5_ = json_node_get_node_type (root);
	if (_tmp5_ != JSON_NODE_ARRAY) {
		g_error ("dictionary.vala:71: malformed format of dictionaries list: toplevel");
	}
	_tmp6_ = json_node_get_array (root);
	_tmp7_ = __vala_JsonArray_copy0 (_tmp6_);
	array = _tmp7_;
	{
		gint i;
		i = 0;
		{
			gboolean _tmp8_;
			_tmp8_ = TRUE;
			while (TRUE) {
				gboolean _tmp9_;
				gint _tmp11_;
				JsonArray* _tmp12_;
				guint _tmp13_ = 0U;
				JsonArray* _tmp14_;
				gint _tmp15_;
				JsonNode* _tmp16_ = NULL;
				JsonNode* _tmp17_;
				JsonNode* node;
				JsonNode* _tmp18_;
				JsonNodeType _tmp19_ = 0;
				JsonNode* _tmp20_;
				JsonObject* _tmp21_ = NULL;
				JsonObject* _tmp22_;
				JsonObject* object;
				JsonObject* _tmp23_;
				DictionaryMetadata* _tmp24_;
				DictionaryMetadata* metadata;
				DictionaryMetadata* _tmp25_;
				const gchar* _tmp26_;
				const gchar* _tmp27_;
				gboolean _tmp28_ = FALSE;
				_tmp9_ = _tmp8_;
				if (!_tmp9_) {
					gint _tmp10_;
					_tmp10_ = i;
					i = _tmp10_ + 1;
				}
				_tmp8_ = FALSE;
				_tmp11_ = i;
				_tmp12_ = array;
				_tmp13_ = json_array_get_length (_tmp12_);
				if (!(((guint) _tmp11_) < _tmp13_)) {
					break;
				}
				_tmp14_ = array;
				_tmp15_ = i;
				_tmp16_ = json_array_get_element (_tmp14_, (guint) _tmp15_);
				_tmp17_ = __vala_JsonNode_copy0 (_tmp16_);
				node = _tmp17_;
				_tmp18_ = node;
				_tmp19_ = json_node_get_node_type (_tmp18_);
				if (_tmp19_ != JSON_NODE_OBJECT) {
					g_warning ("dictionary.vala:79: malformed format of dictionaries list: child objec" \
"t");
					__vala_JsonNode_free0 (node);
					continue;
				}
				_tmp20_ = node;
				_tmp21_ = json_node_get_object (_tmp20_);
				_tmp22_ = __vala_JsonObject_copy0 (_tmp21_);
				object = _tmp22_;
				_tmp23_ = object;
				_tmp24_ = dictionary_metadata_new_from_json_object (_tmp23_);
				metadata = _tmp24_;
				_tmp25_ = metadata;
				_tmp26_ = dictionary_metadata_get_filename (_tmp25_);
				_tmp27_ = _tmp26_;
				_tmp28_ = g_file_test (_tmp27_, G_FILE_TEST_EXISTS);
				if (_tmp28_) {
					GeeMap* _tmp29_;
					DictionaryMetadata* _tmp30_;
					const gchar* _tmp31_;
					const gchar* _tmp32_;
					DictionaryMetadata* _tmp33_;
					GeeList* _tmp34_;
					DictionaryMetadata* _tmp35_;
					const gchar* _tmp36_;
					const gchar* _tmp37_;
					_tmp29_ = self->priv->available_metadata;
					_tmp30_ = metadata;
					_tmp31_ = dictionary_metadata_get_id (_tmp30_);
					_tmp32_ = _tmp31_;
					_tmp33_ = metadata;
					gee_map_set (_tmp29_, _tmp32_, _tmp33_);
					_tmp34_ = self->priv->available;
					_tmp35_ = metadata;
					_tmp36_ = dictionary_metadata_get_id (_tmp35_);
					_tmp37_ = _tmp36_;
					gee_collection_add ((GeeCollection*) _tmp34_, _tmp37_);
				}
				_g_object_unref0 (metadata);
				__vala_JsonObject_free0 (object);
				__vala_JsonNode_free0 (node);
			}
		}
	}
	__vala_JsonArray_free0 (array);
	__vala_JsonNode_free0 (root);
	_g_object_unref0 (parser);
}


static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


DictionaryMetadata** dictionary_registry_list_available (DictionaryRegistry* self, int* result_length1) {
	DictionaryMetadata** result = NULL;
	GeeArrayList* _tmp0_;
	GeeArrayList* _result_;
	GeeArrayList* _tmp16_;
	gint _tmp17_ = 0;
	gpointer* _tmp18_ = NULL;
	DictionaryMetadata** _tmp19_;
	gint _tmp19__length1;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = gee_array_list_new (TYPE_DICTIONARY_METADATA, (GBoxedCopyFunc) g_object_ref, g_object_unref, NULL);
	_result_ = _tmp0_;
	{
		GeeList* _tmp1_;
		GeeList* _tmp2_;
		GeeList* _id_list;
		GeeList* _tmp3_;
		gint _tmp4_;
		gint _tmp5_;
		gint _id_size;
		gint _id_index;
		_tmp1_ = self->priv->available;
		_tmp2_ = _g_object_ref0 (_tmp1_);
		_id_list = _tmp2_;
		_tmp3_ = _id_list;
		_tmp4_ = gee_collection_get_size ((GeeCollection*) _tmp3_);
		_tmp5_ = _tmp4_;
		_id_size = _tmp5_;
		_id_index = -1;
		while (TRUE) {
			gint _tmp6_;
			gint _tmp7_;
			gint _tmp8_;
			GeeList* _tmp9_;
			gint _tmp10_;
			gpointer _tmp11_ = NULL;
			gchar* id;
			GeeArrayList* _tmp12_;
			const gchar* _tmp13_;
			DictionaryMetadata* _tmp14_ = NULL;
			DictionaryMetadata* _tmp15_;
			_tmp6_ = _id_index;
			_id_index = _tmp6_ + 1;
			_tmp7_ = _id_index;
			_tmp8_ = _id_size;
			if (!(_tmp7_ < _tmp8_)) {
				break;
			}
			_tmp9_ = _id_list;
			_tmp10_ = _id_index;
			_tmp11_ = gee_list_get (_tmp9_, _tmp10_);
			id = (gchar*) _tmp11_;
			_tmp12_ = _result_;
			_tmp13_ = id;
			_tmp14_ = dictionary_registry_get_metadata (self, _tmp13_);
			_tmp15_ = _tmp14_;
			gee_abstract_collection_add ((GeeAbstractCollection*) _tmp12_, _tmp15_);
			_g_object_unref0 (_tmp15_);
			_g_free0 (id);
		}
		_g_object_unref0 (_id_list);
	}
	_tmp16_ = _result_;
	_tmp18_ = gee_abstract_collection_to_array ((GeeAbstractCollection*) _tmp16_, &_tmp17_);
	_tmp19_ = _tmp18_;
	_tmp19__length1 = _tmp17_;
	if (result_length1) {
		*result_length1 = _tmp19__length1;
	}
	result = _tmp19_;
	_g_object_unref0 (_result_);
	return result;
}


DictionaryMetadata* dictionary_registry_get_metadata (DictionaryRegistry* self, const gchar* id) {
	DictionaryMetadata* result = NULL;
	GeeMap* _tmp0_;
	const gchar* _tmp1_;
	gpointer _tmp2_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (id != NULL, NULL);
	_tmp0_ = self->priv->available_metadata;
	_tmp1_ = id;
	_tmp2_ = gee_map_get (_tmp0_, _tmp1_);
	result = (DictionaryMetadata*) _tmp2_;
	return result;
}


DictionaryRegistry* dictionary_registry_construct (GType object_type) {
	DictionaryRegistry * self = NULL;
	const gchar* _tmp2_ = NULL;
	gchar* _tmp3_ = NULL;
	gchar* _tmp4_;
	GFile* _tmp5_ = NULL;
	GFile* _tmp6_;
	GFile* file;
	GFile* _tmp7_;
	gboolean _tmp8_ = FALSE;
	GError * _inner_error_ = NULL;
	self = (DictionaryRegistry*) g_object_new (object_type, NULL);
	{
		GInputStream* _tmp0_ = NULL;
		GInputStream* stream;
		_tmp0_ = g_resources_open_stream ("/org/freedesktop/ibus/engine/kkc/dictionaries.json", G_RESOURCE_LOOKUP_FLAGS_NONE, &_inner_error_);
		stream = _tmp0_;
		if (_inner_error_ != NULL) {
			goto __catch1_g_error;
		}
		dictionary_registry_load_metadata_from_stream (self, stream);
		_g_object_unref0 (stream);
	}
	goto __finally1;
	__catch1_g_error:
	{
		GError* e = NULL;
		const gchar* _tmp1_;
		e = _inner_error_;
		_inner_error_ = NULL;
		_tmp1_ = e->message;
		g_error ("dictionary.vala:112: can't load dictionaries list from resource: %s", _tmp1_);
		_g_error_free0 (e);
	}
	__finally1:
	if (_inner_error_ != NULL) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return NULL;
	}
	_tmp2_ = g_get_user_config_dir ();
	_tmp3_ = g_build_filename (_tmp2_, PACKAGE_NAME, "dictionaries.json", NULL);
	_tmp4_ = _tmp3_;
	_tmp5_ = g_file_new_for_path (_tmp4_);
	_tmp6_ = _tmp5_;
	_g_free0 (_tmp4_);
	file = _tmp6_;
	_tmp7_ = file;
	_tmp8_ = g_file_query_exists (_tmp7_, NULL);
	if (_tmp8_) {
		{
			GFile* _tmp9_;
			GFileInputStream* _tmp10_ = NULL;
			GFileInputStream* stream;
			GFileInputStream* _tmp11_;
			_tmp9_ = file;
			_tmp10_ = g_file_read (_tmp9_, NULL, &_inner_error_);
			stream = _tmp10_;
			if (_inner_error_ != NULL) {
				goto __catch2_g_error;
			}
			_tmp11_ = stream;
			dictionary_registry_load_metadata_from_stream (self, (GInputStream*) _tmp11_);
			_g_object_unref0 (stream);
		}
		goto __finally2;
		__catch2_g_error:
		{
			GError* e = NULL;
			GFile* _tmp12_;
			gchar* _tmp13_ = NULL;
			gchar* _tmp14_;
			GError* _tmp15_;
			const gchar* _tmp16_;
			e = _inner_error_;
			_inner_error_ = NULL;
			_tmp12_ = file;
			_tmp13_ = g_file_get_path (_tmp12_);
			_tmp14_ = _tmp13_;
			_tmp15_ = e;
			_tmp16_ = _tmp15_->message;
			g_warning ("dictionary.vala:124: %s exists, but cannot read: %s", _tmp14_, _tmp16_);
			_g_free0 (_tmp14_);
			_g_error_free0 (e);
		}
		__finally2:
		if (_inner_error_ != NULL) {
			_g_object_unref0 (file);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	_g_object_unref0 (file);
	return self;
}


DictionaryRegistry* dictionary_registry_new (void) {
	return dictionary_registry_construct (TYPE_DICTIONARY_REGISTRY);
}


static void dictionary_registry_class_init (DictionaryRegistryClass * klass) {
	dictionary_registry_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (DictionaryRegistryPrivate));
	G_OBJECT_CLASS (klass)->finalize = dictionary_registry_finalize;
}


static void dictionary_registry_instance_init (DictionaryRegistry * self) {
	GeeHashMap* _tmp0_;
	GeeArrayList* _tmp1_;
	self->priv = DICTIONARY_REGISTRY_GET_PRIVATE (self);
	_tmp0_ = gee_hash_map_new (G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, g_free, TYPE_DICTIONARY_METADATA, (GBoxedCopyFunc) g_object_ref, g_object_unref, NULL, NULL, NULL);
	self->priv->available_metadata = (GeeMap*) _tmp0_;
	_tmp1_ = gee_array_list_new (G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, g_free, NULL);
	self->priv->available = (GeeList*) _tmp1_;
}


static void dictionary_registry_finalize (GObject* obj) {
	DictionaryRegistry * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_DICTIONARY_REGISTRY, DictionaryRegistry);
	_g_object_unref0 (self->priv->available_metadata);
	_g_object_unref0 (self->priv->available);
	G_OBJECT_CLASS (dictionary_registry_parent_class)->finalize (obj);
}


GType dictionary_registry_get_type (void) {
	static volatile gsize dictionary_registry_type_id__volatile = 0;
	if (g_once_init_enter (&dictionary_registry_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (DictionaryRegistryClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) dictionary_registry_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (DictionaryRegistry), 0, (GInstanceInitFunc) dictionary_registry_instance_init, NULL };
		GType dictionary_registry_type_id;
		dictionary_registry_type_id = g_type_register_static (G_TYPE_OBJECT, "DictionaryRegistry", &g_define_type_info, 0);
		g_once_init_leave (&dictionary_registry_type_id__volatile, dictionary_registry_type_id);
	}
	return dictionary_registry_type_id__volatile;
}



